<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>单元测试&集成测试</title>
    <url>/posts/a81eede5.html</url>
    <content><![CDATA[<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试又叫模块测试，是对程序中的单个子程序或过程进行测试的过程，也就是说一开始并不是对整个程序进行测试，而是将注意力集中在程序的较小单元。</p>
<a id="more"></a>
<p>其目的是将模块的功能与定义模块的功能规格说明或接口规格说明进行比较。</p>
<p>面向白盒测试</p>
<p> 测试用例的设计方式如下所示。<br>需要两种信息：模块的规格说明和模块的源代码。规格说明一般都规定了模块的输入和输出及模块的功能<br>过程：使用一种或多种白盒测试方法分析模块的逻辑结构，然后使用黑盒测试方法对照模块的规格说明以补充测试用例</p>
<p>当所有功能独立的模块经过严格的单元测试后，就要进入集成测试。</p>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>集成测试的方法有增量测试和非增量测试两种<br>测试单独的模块需要一个特殊的驱动模块和一个或多个桩模块<br>（1）驱动模块是可以用测试工具代替，是编写的小模块，可以把测试用例驱动或传输到被测模块（是用来模拟待测模块的上级模块）<br>（2）桩模块是被测模块调用的模块，用来模拟调用模块的功能</p>
<h4 id="增量测试"><a href="#增量测试" class="headerlink" title="增量测试"></a>增量测试</h4><p>增量测试：先将下一步要测试的模块组装到测试完成的模块集合中，然后再进行测试。随着新功能的增加，不断对应用程序进行测试，在程序的所有部分完成之前，需要一个应用程序的各个部分之间能够相对独立的进行工作（同时完成单元测试和集成测试）。</p>
<p>增量测试的策略有多种，如：自顶向下的测试、自底向上的测试和三明治集成测试</p>
<h5 id="自顶向下的测试"><a href="#自顶向下的测试" class="headerlink" title="自顶向下的测试"></a>自顶向下的测试</h5><p>从程序的顶部或初始模块开始，测试开始后，挑选哪一个后续模块没有确定的方法，但是挑选的后续模块，至少该模块的从属模块（调用他的模块）事先经过了测试（必须开发桩模块）<br>（1）如果程序存在关键部分，应该尽可能早的把关键模块添加进去，所谓关键部分，指的是：某个复杂的模块、某个采用新算法或者容易发生错误的模块<br>（2）在设计模块序列时，I/O模块应该尽可能早的添加进来</p>
<h5 id="自底向上的测试"><a href="#自底向上的测试" class="headerlink" title="自底向上的测试"></a>自底向上的测试</h5><p>从程序模块结构中最底层的模块开始组装和测试，因为模块是自底向上进行组装的，对于一个给定层次的模块，其子模块事前已经完成组装并经过测试，因此不需要编制桩模块。<br>缺点是没有早期程序框架的概念，必须开发驱动模块</p>
<h5 id="三明治集成测试"><a href="#三明治集成测试" class="headerlink" title="三明治集成测试"></a>三明治集成测试</h5><p>是一种混合集成，综合了自顶向下和自底向上两种集成方法的优点，桩模块和驱动模块的开发工作都比较小。过程如下所示。<br>1 确定以某一层为界进行集成，如某层的模块X<br>2 对模块X及其所在层下面的各层使用自底向上的集成策略（小口诀下下三明治）<br>3 对模块X所在层上面的层次使用自顶向下的集成策略（上上三明治）<br>4 对模块X所在层各模块同相应的下层集成（同同三明治）<br>5 对系统进行整体测试</p>
<h4 id="非增量测试"><a href="#非增量测试" class="headerlink" title="非增量测试"></a>非增量测试</h4><p>非增量测试：先独立地测试每个模块（单元测试），然后再将这些模块组成完整的程序</p>
<p>单元测试、集成测试和系统测试的不同<br>1 单元测试是针对软件详细设计做的测试，测试用例设计的主要依据是详细设计<br>2 集成测试是针对软件概要设计做的测试，测试用例设计的主要依据是概要设计<br>3 系统测试是针对软件需求进行的测试，测试用例设计的主要依据是需求规格说明书</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
  </entry>
  <entry>
    <title>黑盒测试</title>
    <url>/posts/84a9cea2.html</url>
    <content><![CDATA[<p>黑盒测试又称数据驱动的测试或者输入输出驱动的测试，不基于内部代码和设计的知识，而是基于需求和功能。</p>
<a id="more"></a>
<p>将程序视为一个黑盒子，测试目标和程序内部的机制和结构无关。如果想要发现程序的所有的错误，判定标准是穷举输入测试，不仅需要测试所有的有效输入还要测试所有的无效输入，但是一般穷举测试很难实现。因此常见的黑盒测试方法如下所示。</p>
<ul>
<li>等价类划分</li>
<li>边界值分析</li>
<li>因果图分析</li>
<li>错误猜测</li>
</ul>
<h3 id="等价划分设计测试用例（关注输入）"><a href="#等价划分设计测试用例（关注输入）" class="headerlink" title="等价划分设计测试用例（关注输入）"></a>等价划分设计测试用例（关注输入）</h3><p>将所有可能的输入数据划分成若干部分，然后从每一部分中选取少数有代表性的数据作为测试用例。</p>
<h4 id="确定等价类"><a href="#确定等价类" class="headerlink" title="确定等价类"></a>确定等价类</h4><p>选取每一个输入条件，将其划分为两个或更多的组。<br>比如两类等价类：有效等价类代表程序的有效输入，利用有效等价类的测试用例检验程序是否实现了规格说明预先规定的功能和性能；无效等价类代表其他任何可能的输入条件，即不正确的输入值，利用这一类测试用例检验程序的冗错能力。<br>一些确定等价类的指导原则：</p>
<ul>
<li>输入条件规定了一个取值范围或取值的个数，即可确定一个有效等价类和两个无效等价类。如1-3，有效等价类为1-3，无效等价类是小于1和大于3</li>
<li>输入条件规定了输入值的集合，在集合内的有效等价类和不在集合内的无效等价类</li>
<li>输入条件规定了必须是的情况</li>
</ul>
<h4 id="生成测试用例"><a href="#生成测试用例" class="headerlink" title="生成测试用例"></a>生成测试用例</h4><ul>
<li>为每个等价类设置一个不同的编号</li>
<li>编写新的测试用例，尽可能多的覆盖那些尚未被涵盖的有效等价类，直到所有的有效等价类都被覆盖</li>
<li>编写新的测试用例，覆盖一个且仅一个尚未被涵盖的无效等价类，直到所有的无效等价类都被测试用例覆盖</li>
</ul>
<p>用单个测试用例覆盖无效等价类，是因为某些特定的输入错误检查可能会屏蔽或取代其他输入错误检查</p>
<p>但是等价类划分仍然忽略某些特定类型的高效测试用例</p>
<h3 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h3><p>边界条件指的是输入和输出等价类中那些恰好处于边界、或超过边界、或在边界以下的状态，它和等价类划分有以下不同：</p>
<ul>
<li>与从等价类中挑选出任意一个元素作为代表不同，边界值分析需要选择一个或多个元素，以便等价类的每个边界都经过一次测试。（PS：边界值也可能包含在有效等价类中）</li>
<li>与仅仅关注输入条件不同，还需要考虑从结果空间（输出等价类）</li>
</ul>
<p>边界值分析考察的是正处于等价划分边界或边界附近的状态</p>
<p>设计测试用例通用指南</p>
<ul>
<li>输入条件规定一个输入值范围，应针对范围的边界设计测试用例，针对刚刚越界的情况设计无效测试用例，如-1到1，针对-1、1、-1.001和1.001</li>
<li>输入条件规定输入值的数量，针对最小数量，最大数量，以及比最小数量少1个和比最大数量多1个的情况设计测试用例</li>
<li>输出条件，输入条件的边界并不代表输出范围的边界，应对输出条件的范围进行测试</li>
<li>如果输入输出是一个有序的序列，那么应特别注意该序列的第一个和最后一个元素</li>
</ul>
<p>常见的边界值通常表现在界面屏幕、数组、报表和循环上，其表现方式如下：<br>1 屏幕上的光标在最左上、最右下位置<br>2 数组元素的第一个和最后一个<br>3 报表的第一行和最后一行<br>4 循环的第0次、第1次、倒数第2次和最后1次</p>
<p>等价类划分和边界值分析方法都未对输入条件的组合进行分析（输入之间存在联系）</p>
<h3 id="因果图分析"><a href="#因果图分析" class="headerlink" title="因果图分析"></a>因果图分析</h3><p>根据条件组合而生成测试用例的系统性方法，过程如下：<br>1 将规格说明分解为可执行的片段，因果图不善于处理较大的规格说明<br>2 确定规格说明中的因果关系，因即是一个明确的输入条件或输入条件的等价类，果就是输出条件或系统转换（输入对程序或系统状态的延续影响），因果关系一旦确定，每个因和果都被赋予唯一的编号<br>3 分析规格说明的语义内容，并将其转换为连接因果关系的布尔图，即因果图<br>4 给图加上注解符号，说明由于语法或环境的限制而不能联系起来的因和果<br>5 通过仔细跟踪图中的状态变化情况，将因果图转换成一个有限项的判定表，表的每一列代表一个测试用例<br>6 将判定表转换为测试用例</p>
<h4 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h4><img src="/posts/84a9cea2/%E5%9B%A0%E6%9E%9C%E5%9B%BE%E7%AC%A6%E5%8F%B7.jpg" class title="因果图符号">
<p>1 identity函数表示如果 a=1，则b=1（恒等）<br>2 NOT函数 表示如果 a=1，则b=0（非）<br>3 OR函数表示如果a或b或c等于1，则d=1（或）<br>4 AND函数如果a和b都等于1，则c=1（与）</p>
<h4 id="约束符号"><a href="#约束符号" class="headerlink" title="约束符号"></a>约束符号</h4><p>E（Exclusive）异或：表示至多一个为1<br>I（Inclusive）或：表示至少一个为1<br>O（One and Only）唯一：只有一个是1<br>R（Require）要求：表示a为1，b必须是1<br>M（Mask）强制：表示a是1，则b必须是0</p>
<p>因果图将规格说明转换成一个布尔逻辑网络图</p>
<h3 id="错误猜测"><a href="#错误猜测" class="headerlink" title="错误猜测"></a>错误猜测</h3><p>利用直觉和经验，列举出可能犯的错误或错误易发情况的清单，然后依据清单来编写用例</p>
<p>组合测试策略<br>1 如果规格说明中包含输入条件组合的情况，优先使用因果图分析法<br>2 在任何情况下都应该使用边界值分析方法，是对输入和输出边界进行分析<br>3 应为输入和输出确定有效和无效等价类，在必要情况下对上面确定的用例进行补充<br>4 使用错误猜测方法增加更多的测试用例<br>5 针对上述测试用例集检查程序的逻辑结构，应使用判定覆盖、条件覆盖、判定/条件覆盖或多重条件覆盖</p>
<p>除此之外，黑盒测试还有判断表法、状态图法、随机数据法等等</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
  </entry>
  <entry>
    <title>白盒测试</title>
    <url>/posts/e609c8f4.html</url>
    <content><![CDATA[<h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>白盒测试又称逻辑驱动测试或结构测试，允许检查内部的结构，基于应用程序内部逻辑的知识，通过语句、分支、路径和条件的覆盖率。<br>同黑盒测试的穷举输入类似，如果将程序中每条语句至少执行一次，即穷举路径测试，不切实际，即便实现还是有错误</p>
<a id="more"></a>
<p>原因如下：</p>
<ul>
<li>当这个程序本身就是错误的程序，就难以发现其错误</li>
<li>当程序缺少了某些路径，穷举不能发现缺少的路径</li>
<li>不会暴露数据敏感错误</li>
</ul>
<h3 id="逻辑驱动覆盖测试"><a href="#逻辑驱动覆盖测试" class="headerlink" title="逻辑驱动覆盖测试"></a>逻辑驱动覆盖测试</h3><p> 逻辑驱动覆盖测试是以程序内部的逻辑结构为基础设计测试用例的方法，是最传统、最经典的白盒测试技术。<br>常见的覆盖标准有七种，如下所示：</p>
<ul>
<li>语句覆盖Statement Coverage(SC)</li>
<li>判定覆盖Decision Coverage(DC)</li>
<li>条件覆盖Condition Coverage(CC)</li>
<li>判定/条件覆盖Decision/Condition Coverage(D/CC)</li>
<li>多重条件覆盖Condition Combination Coverage(CCC)</li>
<li>路径覆盖Path Coverage(PC)</li>
<li>修订的条件/判定覆盖Modified Condition/Decision Coverage(MC/DC)</li>
</ul>
<p>通过一段简单的小程序，来说明不同的覆盖标准。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">j = 0</span><br><span class="line">if x &gt; 3 and z &lt; 10:</span><br><span class="line">    j == 1</span><br><span class="line">if x == 4 or y &gt; 5:</span><br><span class="line">    j == 2</span><br><span class="line">j == 3</span><br></pre></td></tr></table></figure>
<p>程序流程图如下所示：</p>
<img src="/posts/e609c8f4/%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" class title="示例程序流程图">

<h4 id="语句覆盖"><a href="#语句覆盖" class="headerlink" title="语句覆盖"></a>语句覆盖</h4><p>设计若干测试用例，运行所测程序，使得每条语句至少都执行一次。语句覆盖是最弱的逻辑覆盖准则。（PS：这里的若干，尽量是越少越好）<br>应满足以下覆盖情况:执行路径abd。选择测试用例: x=4,y=5,z=5。<br>优点：直观的从代码中得到测试用例，不用细分每条判定表达式<br>缺点：对隐藏的条件和可能到达的隐式分支无法测试，它只在乎运行一次，而不考虑其他情况。</p>
<h4 id="判定覆盖（分支覆盖）"><a href="#判定覆盖（分支覆盖）" class="headerlink" title="判定覆盖（分支覆盖）"></a>判定覆盖（分支覆盖）</h4><p>使得程序中每个判断都至少有一个为真和为假的输出结果，即每条分支路径都必须至少遍历一次<br>判定覆盖是比语句覆盖更强的准则，比判定覆盖更强的是条件覆盖<br>应满足以下覆盖情况:执行路径abd和ace。<br>选择测试用例: x=4,y=5,z=5；x=2,y=5,z=5</p>
<p>优点：测试能力更强，无须细分每个判定即可得到测试用例，测试路径更多<br>缺点：对于多个逻辑条件组合而成的判定语句并不友好，如果仅判断最终结果，忽略每个条件的取值就会遗漏测试路径</p>
<h4 id="条件覆盖"><a href="#条件覆盖" class="headerlink" title="条件覆盖"></a>条件覆盖</h4><p>确保将一个判断中的每个条件的所有可能的结果都至少执行一次。<br>选择测试用例: x=4,y=6,z= 5;x=2,y=5,z=5;x=4,y=5,z=15。</p>
<p>优点：比判定覆盖增加了对符合判定情况的测试，增加了测试路径</p>
<p>缺点：如果每个判断中每个条件的可能取值至少满足一次，但是覆盖了条件的测试用例不一定会覆盖判定</p>
<h4 id="判定-条件覆盖"><a href="#判定-条件覆盖" class="headerlink" title="判定/条件覆盖"></a>判定/条件覆盖</h4><p>同时满足判定覆盖和条件覆盖。将一个判断中的每个条件的所有可能的结果至少执行一次，将每个判断的所有可能的结果至少执行一次，将每个入口点都至少调用一次（看似所有条件的所有结果都执行了，实际由于有些特定条件会屏蔽其他条件，常常并不能全部都执行）<br>应满足以下覆盖情况:执行路径abd和ace。  选择测试用例: x=4,y=6,z=5;x=2,y=5,z=11。</p>
<p>优点：既满足判定覆盖又满足条件覆盖<br>缺点：不满足多重条件组合覆盖，又忽略了路径覆盖的问题，没有考虑单个判定对整体结果的影响，不能发现程序中的逻辑错误。</p>
<p>关于与和或，如果与表达式有个条件为假，那么无需计算该表达式中的后续条件<br>如果或表达式中有个条件为真，那么同样后续条件也无需计算，因此条件覆盖或判定/条件覆盖不一定能发现逻辑表达式中的错误</p>
<h4 id="多重条件覆盖"><a href="#多重条件覆盖" class="headerlink" title="多重条件覆盖"></a>多重条件覆盖</h4><p>可以部分解决上述问题，将每个判定中的所有可能的条件结果组合以及所有的入口点都至少执行一次</p>
<ul>
<li>每个判断的所有结果都至少执行一次</li>
<li>将所有的程序入口都至少调用一次，以确保全部的语句都至少执行一次</li>
<li>对于多重条件判断的程序，需要足够的测试用例，将每个判断的所有可能的条件结果的组合，以及所有的入口点都至少执行一次</li>
</ul>
<h4 id="路径覆盖"><a href="#路径覆盖" class="headerlink" title="路径覆盖"></a>路径覆盖</h4><p>使程序中每一条可能的路径至少执行一次。<br>应满足以下覆盖情况：执行路径abd，ace，acd和abe<br>选择测试用例: x=4,y=6,z=5; x=2,y=5,z=5; x=4,y=5,z=15; x=5,y=5,z=9<br>缺点：不一定保证条件的所有组合都覆盖，需要设计大量的测试用例，要对循环，条件组合，分支选择都要进行测试。</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
  </entry>
  <entry>
    <title>静态测试和动态测试</title>
    <url>/posts/5b2bc680.html</url>
    <content><![CDATA[<p>根据程序是否运行，测试分为静态测试和动态测试。</p>
<a id="more"></a>

<h3 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h3><p>静态测试就是静态分析,不实际运行被测软件，对模块的源代码进行分析,查找错误或收集一些度量数据。静态测试采用人工检测（如代码评审）和计算机辅助静态分析手段进行检测，只进行特性分析。<br>计算机辅助静态分析:利用静态分析工具检查缺陷和问题，如用错的局部变量和全局变量,不匹配的参数，潜在的死循环等。<br>静态测试就是静态地检查程序代码、界面或文档中可能存在的错误的过程。</p>
<ul>
<li>代码测试即对代码进行测试，主要测试代码是否符合相应的标准和规范。</li>
<li>界面测试即对界面进行测试，主要测试软件的实际界面与需求中的说明是否相符</li>
<li>文档测试即对文档进行测试，主要测试用户手册和需求说明书的内容是否符合用户的实际需求。</li>
</ul>
<h3 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h3><p>动态测试指的是实际运行被测程序,输人相应的测试数据,检查实际输出结果和预期结果是否相符的过程。所以判断一个测试属于动态测试还是静态测试，唯一的标准就是看是否运行程序。<br>动态测试是通过观察代码运行时的动作,来提供执行跟踪、时间分析,以及测试覆盖度方面的信息。动态测试通过真正运行程序发现错误,通过有效的测试用例,对应的输入输出关系分析被测程序的运行情况</p>
<h3 id="不同的测试方法间的关系"><a href="#不同的测试方法间的关系" class="headerlink" title="不同的测试方法间的关系"></a>不同的测试方法间的关系</h3><p>各种测试方法有各自的目标和侧重点,在实际工作中应将这两种方法结合起来运用，以达到更完美的效果。<br>测试方法各有所长，每种方法都可设计出一组实用有效的用例,用这组测试用例可以比较容易地发现某种类型的错误，却不易发现另一种类型的错误。因此在实际测试中，应结合各种测试方法,形成综合策略。</p>
<ul>
<li>在单元测试时主要用白盒测试;</li>
<li>在集成测试时既可以用白盒测试方法也可以用黑盒测试方法,或者用白盒与黑盒结合的灰盒测试方法;</li>
<li>系统测试时主要用黑盒测试。</li>
<li>白盒测试有可能采用动态测试方法，即运行程序并分析代码结构;也有可能采用静态测试方法，即不运行程序,只静态查看代码。</li>
</ul>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
  </entry>
  <entry>
    <title>软件开发过程模型及测试模型</title>
    <url>/posts/a102dba1.html</url>
    <content><![CDATA[<p>本文将学习软件开发过程模型和测试模型</p>
<a id="more"></a>
<h3 id="软件开发过程模型"><a href="#软件开发过程模型" class="headerlink" title="软件开发过程模型"></a>软件开发过程模型</h3><p>  软件开发过程模型有瀑布模型、原型模型、螺旋模型、增量模型、喷泉模型、形式化方法、敏捷模型等很多种，本文主要介绍瀑布模型、原型模型、螺旋模型三种最常见的模型。</p>
<h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><p>  将软件生存周期的各项活动规定为按固定顺序而连接的若干阶段工作，强调系统开发应有完整的周期，将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护六个基本活动，并规定他们自上而下、相互衔接的固定次序，如同瀑布，逐级下落。<br>  其过程是从上一项活动接收该项活动的工作对象作为输入，用这个输入实施这项活动应完成的内容给出这项活动的工作成果，作为输出传给下一项。同时评审这项活动的实施，如果确认，则继续下一项活动，否则返回前面。</p>
<img src="/posts/a102dba1/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.jpg" class title="瀑布模型">

<p>优点：</p>
<ul>
<li>为项目提供了按阶段划分的检查点</li>
<li>当前一阶段完成后，只需要关注后续阶段</li>
<li>提供了一个模版</li>
</ul>
<p>缺点：</p>
<ul>
<li>不适应用户需求的变化（很重要）</li>
<li>各个阶段的划分完全固定，阶段之间产生大量文档</li>
<li>开发模型为线型，用户只有等到整个过程结束才能看到开发成果，增加开发风险（线性过程太理想化）</li>
</ul>
<h4 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h4><p>  通过向用户提供原型获取用户的反馈，使开发出的软件能真正反映用户的需求。逐步求精的完善原型，显然比瀑布模型能对用户的反馈最初更快的响应。</p>
<p>优点：</p>
<ul>
<li>减少设计中的错误和开发过程中的风险</li>
<li>缩短开发周期，加快工程进度，更快</li>
<li>降低成本</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果告诉用户重新开发该产品，这样就会很麻烦，不利于对工程的继续开展。</li>
</ul>
<h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p>周期性的进行系统开发，这个模型的每一个周期都包括制定计划、风险分析、实施工程和客户评估四个阶段，并且由这四个阶段进行迭代。软件开发每迭代一次，软件开发就会前进一个层次。</p>
<img src="/posts/a102dba1/%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B.png" class title="螺旋模型">
<p>（图片来自网络）<br>优点：</p>
<ul>
<li>设计更加灵活，可以在项目的各个阶段进行变更</li>
<li>以小的分段构建大型系统，成本计算更加简单</li>
<li>客户始终参与到每个阶段的开发，保证项目不偏离正确方向</li>
<li>随着项目的开发，客户始终掌握项目的最新信息</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要相当丰富的风险评估和专门的知识，强调风险分析</li>
<li>过多的迭代次数会增加开发成本，延迟提交时间。</li>
</ul>
<h3 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h3><p>下面是几种典型的软件测试模型，V模型、W模型和X模型，这些模型从不同程度反映了软件开发与测试的关系。</p>
<h4 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h4><p>在软件测试中V模型是最广为人知的模型。如图所示。</p>
<img src="/posts/a102dba1/%E4%BC%A0%E7%BB%9FV%E6%A8%A1%E5%9E%8B.jpg" class title="传统V模型">
<p>V模型中的过程从左到右,描述了基本的开发过程和测试行为。V模型的价值在于它非常明确地标明了测试过程中存在的不同级别,并且清楚地描述了这些测试阶段和开发过程期间各阶段的对应关系。</p>
<ul>
<li>单元测试的目的是根据详细设计说明书验证单元模块是否符合要求，发现代码编写过程中存在的问题。</li>
<li>集成测试的目的是根据概要设计说明书验证各个模块是否已经集成到一起，各个模块之间的接口是否存在问题。</li>
<li>系统测试的目的是根据需求说明书验证软件是否符合用户的需求，系统是否能够正常工作。</li>
</ul>
<p>V模型的局限性是把测试作为编码之后的最后一个活动，需求分析等前期产生的错误直到后期的验收测试才能发现缺陷。</p>
<h4 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a>W模型</h4><p>w模型是V模型的发展，强调的是测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、功能和设计同样要测试。测试与开发是同步进行的，从而有利于尽早地发现问题。<br>缺点：不能支持迭代、自发性以及变更调整。<br>如图所示：</p>
<img src="/posts/a102dba1/W%E6%A8%A1%E5%9E%8B.jpg" class title="W模型">
<p>（图片来自网络）</p>
<h4 id="X模型"><a href="#X模型" class="headerlink" title="X模型"></a>X模型</h4><p>软件测试的X模型也是对V模型的改进，如图所示。</p>
<img src="/posts/a102dba1/X%E6%A8%A1%E5%9E%8B.jpeg" class title="X模型">
<p>（图片来自网络）<br>软件测试的X模型的左边描述的是针对单独程序片段所进行的相互分离的编码和测试，此后将进行频繁的交接，通过集成最终成为可执行的程序，然后再对这些可执行程序进行测试。已通过集成测试的成品可以进行封装并提交给用户，也可以作为更大规模和范围内集成的一部分。多根并行的曲线表示变更可以在各个部分发生。X模型还定位了探索性测试，这是不进行事先计划的特殊类型的测试，这一方式往往能帮助有经验的测试人员在测试计划之外发现更多的软件错误。但是对测试员的熟练程度要求比较高。</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
  </entry>
  <entry>
    <title>python之字符串格式化</title>
    <url>/posts/42e5ab5d.html</url>
    <content><![CDATA[<p>今天来学习字符串格式化</p>
<a id="more"></a>
<h2 id="Python字符串格式化"><a href="#Python字符串格式化" class="headerlink" title="Python字符串格式化"></a>Python字符串格式化</h2><h3 id><a href="#" class="headerlink" title="%"></a>%</h3><p>用<strong>格式化符号%</strong>进行格式化字符串时，Python使用一个字符串作为模板。模板中有格式符，这些格式符为真实值预留位置，并说明真实数值应该呈现的格式。Python用一个tuple将多个值传递给模板，每个值对应一个格式符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"%s has %d dollars"</span> % (<span class="string">'Tom'</span>, <span class="number">200</span>))</span><br><span class="line">Tom has <span class="number">200</span> dollars</span><br></pre></td></tr></table></figure>

<p>当我们的模板中含有过多的格式符时，仅仅依靠格式符的顺序传入真实值，有可能会出现衣服扣子扣错位置的现象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"%s is %d years old and %s was born in %s"</span> % (<span class="string">'Tom'</span>, <span class="string">'15'</span>, <span class="string">'Sanfrancisco'</span>))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: %d format: a number <span class="keyword">is</span> required, <span class="keyword">not</span> str</span><br></pre></td></tr></table></figure>

<p>为了避免这种现象，我们可以给格式符指定名称，用字典来传递真实值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"%(name1)s is %(age)d years old and %(name2)s was born in %(place)s"</span> % &#123;<span class="string">'name1'</span>: <span class="string">'Tom'</span>, <span class="string">'age'</span>: <span class="number">15</span>, <span class="string">'name2'</span>: <span class="string">'Alice'</span>, <span class="string">'place'</span>: <span class="string">'Sanfrancisco'</span>&#125;)</span><br><span class="line">Tom <span class="keyword">is</span> <span class="number">15</span> years old <span class="keyword">and</span> Alice was born <span class="keyword">in</span> Sanfrancisco</span><br></pre></td></tr></table></figure>

<p>除了%d和%s外，还有如下字符串格式符的类型码</p>
<table>
<thead>
<tr>
<th>格式符</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%c</td>
<td>单个字符</td>
</tr>
<tr>
<td>%d, %i</td>
<td>十进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>八进制整数</td>
</tr>
<tr>
<td>%x</td>
<td>十六进制整数</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%e</td>
<td>指数(e为底)</td>
</tr>
</tbody></table>
<p>除此之外，我们还可以对格式符的格式进行控制，模板：%[(name)][flags][width].[precision]typecode</p>
<ul>
<li><p>其中name是名字</p>
</li>
<li><p>flags是标志位，可以有+，-，’ ‘， 0，+表示右对齐。-表示左对齐。’ ‘为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐，0表示使用0填充</p>
</li>
<li><p>width表示显示宽度</p>
</li>
<li><p>precision表示小数点后精度</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"%.3f"</span> % <span class="number">3.1415926</span>)</span><br><span class="line"><span class="number">3.142</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"%03d"</span> % <span class="number">1</span>)</span><br><span class="line"><span class="number">001</span></span><br></pre></td></tr></table></figure>



<h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p>相对基本格式化输出采用‘%’的方法，format功能更强大，该函数把字符串当成一个模板，通过传入的参数进行格式化，并且使用大括号‘{}’作为特殊字符代替‘%’</p>
<p>该函数提供了多种位置匹配方式</p>
<ul>
<li>不带编号</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"My name is &#123;&#125;"</span>.format(<span class="string">'Jerry'</span>))</span><br><span class="line">My name <span class="keyword">is</span> Jerry</span><br></pre></td></tr></table></figure>

<ul>
<li>带数字编号</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"&#123;0&#125; is &#123;1&#125; years old"</span>.format(<span class="string">'Tom'</span>, <span class="number">12</span>))</span><br><span class="line">Tom <span class="keyword">is</span> <span class="number">12</span> years old</span><br></pre></td></tr></table></figure>

<ul>
<li>带名称匹配</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"&#123;name&#125; is &#123;age&#125; years old"</span>.format(name=<span class="string">'Tom'</span>, age=<span class="number">12</span>))</span><br><span class="line">Tom <span class="keyword">is</span> <span class="number">12</span> years old</span><br></pre></td></tr></table></figure>

<ul>
<li>通过list匹配</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="string">'Tom'</span>, <span class="number">12</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"&#123;l[0]&#125; is &#123;l[1]&#125; years old"</span>.format(l=list))</span><br><span class="line">Tom <span class="keyword">is</span> <span class="number">12</span> years old</span><br></pre></td></tr></table></figure>

<ul>
<li>通过字典匹配</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict = &#123;<span class="string">'name'</span>: <span class="string">'Tom'</span>, <span class="string">'age'</span>: <span class="number">12</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"&#123;d[name]&#125; is &#123;d[age]&#125; years old"</span>.format(d=dict))</span><br><span class="line">Tom <span class="keyword">is</span> <span class="number">12</span> years old</span><br></pre></td></tr></table></figure>

<p>和%不同的是，format函数不需要提前指定真实值的类型，这样的设定更符合python语言的特性，且使用起来更加方便，当我们需要格式化输出指定的内容时，只需要在{}里添加内容即可</p>
<ul>
<li>保留小数点位数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"&#123;:.3f&#125;"</span>.format(<span class="number">3.1415926</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>转为二进制</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"&#123;:b&#125;"</span>.format(<span class="number">2</span>))</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>转为十六进制</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"&#123;:x&#125;"</span>.format(<span class="number">15</span>))</span><br><span class="line">f</span><br></pre></td></tr></table></figure>

<p>其他功能</p>
<ul>
<li>格式化时间</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;:%Y-%m-%d %X&#125;'</span>.format(now))</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">51</span></span><br></pre></td></tr></table></figure>

<ul>
<li>format函数定义的字符串模板还可以当做函数使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_fnc = <span class="string">"&#123;&#125; is the biggest company in the world"</span>.format  <span class="comment"># 此处print_fnc为一个函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_fnc(<span class="string">'Apple'</span>)</span><br><span class="line"><span class="string">'Apple is the biggest company in the world'</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之collections</title>
    <url>/posts/b63a9447.html</url>
    <content><![CDATA[<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Python collections模块是一个非常实用且高效的模块，今天我们就来一起探索。</p>
<a id="more"></a>

<h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>Counter是一个简单的计数器，传入的Counter的对象可以为字符串，list或者dict，返回的Counter对象对字符串，list或者dict里的元素进行简单的计数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Counter(<span class="string">'helloworld!'</span>)</span><br><span class="line">Counter(&#123;<span class="string">'l'</span>: <span class="number">3</span>, <span class="string">'o'</span>: <span class="number">2</span>, <span class="string">'!'</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">1</span>, <span class="string">'h'</span>: <span class="number">1</span>, <span class="string">'r'</span>: <span class="number">1</span>, <span class="string">'w'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Counter([<span class="string">'Tom'</span>, <span class="string">'Jerry'</span>, <span class="string">'Tom'</span>, <span class="string">'Alice'</span>])</span><br><span class="line">Counter(&#123;<span class="string">'Tom'</span>: <span class="number">2</span>, <span class="string">'Jerry'</span>: <span class="number">1</span>, <span class="string">'Alice'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Counter(&#123;<span class="string">'cat'</span>: <span class="number">2</span>, <span class="string">'dog'</span>: <span class="number">4</span>&#125;)</span><br><span class="line">Counter(&#123;<span class="string">'dog'</span>: <span class="number">4</span>, <span class="string">'cat'</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到，一个Counter对象是字典的一个子类，传入任意iterable时，会按key出现次数的顺序对Counter对象里的元素排序。当访问元素的时候，如果引用的key不存在于字典中，不会弹出keyerror而是返回0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(&#123;<span class="string">'cat'</span>: <span class="number">2</span>, <span class="string">'dog'</span>: <span class="number">4</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">'duck'</span>]</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>此外，Counter对象还有一些常用的方法</p>
<ul>
<li>elements()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(<span class="string">'helloworld!'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(c.elements())</span><br><span class="line">[<span class="string">'!'</span>, <span class="string">'e'</span>, <span class="string">'d'</span>, <span class="string">'h'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'w'</span>]</span><br></pre></td></tr></table></figure>

<p>该方法返回Counter中的所有key，按照一定顺序排序</p>
<ul>
<li>most_common()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Counter(<span class="string">'dsfhbfshddas'</span>).most_common(<span class="number">3</span>)</span><br><span class="line">[(<span class="string">'d'</span>, <span class="number">3</span>), (<span class="string">'s'</span>, <span class="number">3</span>), (<span class="string">'f'</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>

<p>该方法返回Counter中出现次数最多的k个(key, value) pair对</p>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>list对象通过索引访问元素的时间复杂度为O(1)，但是append和pop操作只能从尾部进行，当数据量很大时，我们想对头部元素进行操作时就会很耗时。deque是Collections模块里一个双向队列，支持从两端pop或者append元素，且两端的时间开销都为O(1)</p>
<p>deque对象支持从list或者字符串创建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>deque(<span class="string">'abcde'</span>)</span><br><span class="line">deque([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>append, appendleft</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = deque(<span class="string">'bcde'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.append(<span class="string">'f'</span>)</span><br><span class="line">deque([<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.appendleft(<span class="string">'a'</span>)</span><br><span class="line">deque([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>pop, popleft</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = deque(<span class="string">'bcde'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop()</span><br><span class="line"><span class="string">'e'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.popleft()</span><br><span class="line"><span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">deque([<span class="string">'c'</span>, <span class="string">'d'</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>extend, extendleft</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = deque(<span class="string">'cde'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.extend(<span class="string">'fgh'</span>)</span><br><span class="line">deque([<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.extendleft(<span class="string">'ab'</span>)</span><br><span class="line">deque([<span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>])</span><br></pre></td></tr></table></figure>

<p>可见，在extendleft方法中，iterable参数中的顺序将被反过来添加。</p>
<ul>
<li>rotate</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = deque(<span class="string">'cde'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.rotate(<span class="number">2</span>)   <span class="comment"># right rotation</span></span><br><span class="line">deque([<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.rotate(<span class="number">-1</span>)  <span class="comment"># left rotation</span></span><br><span class="line">deque([<span class="string">'e'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br></pre></td></tr></table></figure>



<h3 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h3><p>namedtuple用来创建自定义的tuple对象，<strong>支持用属性和索引访问tuple里的元素</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>clock = namedtuple(<span class="string">'clock'</span>, [<span class="string">'hour'</span>, <span class="string">'minute'</span>, <span class="string">'second'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = clock(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># 12点0分0秒</span></span><br><span class="line">clock(hour=<span class="number">12</span>, minute=<span class="number">0</span>, second=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1.hour</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1[<span class="number">0</span>]</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>我们用namedtuple很方便地定义了一种时钟类型的数据结构，且具有tuple的不变形，十分好用</p>
<h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>我们在使用dict时，key是无序的，因此在遍历dict的过程中无法确定key的顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>要确定key的顺序可以使用OrderedDict，<strong>它会按照插入key的顺序排列</strong>，注意不是key本身的顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = OrderedDict([(<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</span><br><span class="line">OrderedDict([(<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'d'</span>] = <span class="number">5</span></span><br><span class="line">OrderedDict([(<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'c'</span>, <span class="number">3</span>), (<span class="string">'d'</span>, <span class="number">5</span>)])</span><br></pre></td></tr></table></figure>

<p>此外，新版OrderedDict还支持key顺序移动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = OrderedDict.fromkeys(<span class="string">'abcde'</span>)</span><br><span class="line">OrderedDict([(<span class="string">'a'</span>, <span class="literal">None</span>), (<span class="string">'b'</span>, <span class="literal">None</span>), (<span class="string">'c'</span>, <span class="literal">None</span>), (<span class="string">'d'</span>, <span class="literal">None</span>), (<span class="string">'e'</span>, <span class="literal">None</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.move_to_end(<span class="string">'b'</span>)  <span class="comment"># 将b移动到末尾</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">""</span>.join(d.keys())</span><br><span class="line"><span class="string">'acdeb'</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>我的NO.1小小飞mavic mini</title>
    <url>/posts/b913c8d0.html</url>
    <content><![CDATA[<p>2019年的圣诞节，收到了我的第一款无人机—-小小飞，大疆mavic mini</p>
<a id="more"></a>
<p>激动之余还录制了我的拆箱视频，毕竟我以前也只玩过一款无人机，还是实验室的那已经是老的不能再老的老爷机，所以收到这个精致的小小飞，我真的超开心（关键还是免费，哈哈哈哈）</p>
<p>拆开第一感觉就是小，真的很小，又小又轻，太激动了，大晚上就迫不及待的试飞了，真的太佩服DJI的工程师了，一件精致的工艺品，从机械结构的设计，各个卡槽的精密装配，再到软件系统的友好界面，整个试飞体验的都让我对DJI的佩服的五体投地，甘拜下风，心服口服……此处省略多个夸奖词汇 BUT</p>
<p>mavic mini真的很不错，BUT，往往第一代产品都有些许不如意，这样才能符合正常的产品迭代，试飞后我也发现了一些小问题，这是一个非常好的风向，因为只有发现问题，才能获得机会，获得再次把握市场的机会</p>
<h4 id="质量轻VS新手小白"><a href="#质量轻VS新手小白" class="headerlink" title="质量轻VS新手小白"></a>质量轻VS新手小白</h4><p>mini主打的质量轻，无可厚非，但是宣传中也说到，降低飞行门槛，“你也能飞”，意味着新手小白也可以体验无人机的乐趣，但是没有四向避障，mini为了减轻质量，只有底部避障，阉割了四向避障，这就略不合理了，一个新手真的不能一上手就立刻掌握住飞行速度。<br>以下是一个新手的初次上手体验：我的第一杆操作就很激动，兴奋，所以手上没注意力量，一飞冲天差点撞到旁边的树枝，在我看到撞到树枝的时候，我又惊慌失措（毕竟初次使用各种都不是很熟悉），手上力气更难以控制，甚至找不到东西南北，果然华丽丽的飞来飞去，撞来撞去，或许，这就是套装的魅力（这也是赚钱的魅力），如果你有一个防护桨的话，你就会十分安心了，但是带了防护桨，整个mini就不迷你了，看着有点臃肿</p>
<h4 id="体积小VS找不到"><a href="#体积小VS找不到" class="headerlink" title="体积小VS找不到"></a>体积小VS找不到</h4><p>顾名思义mini就是迷你，确实我们的确做的也很小，手掌那么大，很便携，甚至出门不需要背包，抄兜里就可以，真好。大晚上我怀着无比激动的心情，没飞多高，我就看不到我的小小飞了，可能是因为黑夜没有给我一双黑色的眼睛吧，我真的看不到了。白天还好点，但是也好不多，仰头往上看，飞到哪了啊，看不到啊，又没有避障，所以不敢乱飞，只能在视线可见范围内。主要飞到空中，看不到前后左右，不知道对着我的到底是机头还是机屁股，前后左右不知道怎么操作，导致越飞越远，越飞越找不到，嗯，一定是我技术不熟练的原因，此外我还需要一个亮闪闪灯，毕竟自带的我看不清。更新：查了一下，好像飞丢了，DJI给新的，太棒了吧</p>
<h4 id="四向避障VS新手的脑洞大开"><a href="#四向避障VS新手的脑洞大开" class="headerlink" title="四向避障VS新手的脑洞大开"></a>四向避障VS新手的脑洞大开</h4><p>我在想，我想的还真不少，没有四向避障的话，如果飞行过程中图传信号丢失（这是一个假设），mini没有四向避障，也没有图像信息，那岂不是再飞的时候就炸机了（炸了买新的呗）</p>
<p>如果不给摄像头带护壳，那么没有四向避障，摄像头也会撞击吧，提问：你问啥不给摄像头带保护壳，回答：我忘了</p>
<h4 id="失联的小小飞"><a href="#失联的小小飞" class="headerlink" title="失联的小小飞"></a>失联的小小飞</h4><p>如果我的小小飞失联了咋办，风太大，不能自动返航，（话说这么轻抗风性如何，还没试，主要是没风，这里假设风大），偏偏这个时候没电，我的DJI app会提示我，我的小小飞在哪里嘛，最好手机界面有个清晰的地图显示</p>
<h4 id="拍照视频"><a href="#拍照视频" class="headerlink" title="拍照视频"></a>拍照视频</h4><p>作为一个美美哒的女孩子，除了玩，肯定是拍照啊，拍视频做vlog，mini的像素还可以，对我来说够了，但是专业人士可能要求更高吧，那你需要选择其他款式的无人机，视频拍摄的时候不能手动调节参数吧，虽然我也用不到调节，我很粗糙，能看的视频对我来说就够用了。没有内置存储也很尴尬，毕竟照片视频的内存还挺大的，稍微内置一点存储感觉也好啊，俺的单机也莫有SD卡，还是套装给力，再次夸赞套装的想法。<br>没有发现自动跟随，查了一下，mini也没有自动跟随，现在这个样子真的已经不错了，别想太多</p>
<h4 id="充电"><a href="#充电" class="headerlink" title="充电"></a>充电</h4><p>充电宝可以充电嘛，我还没试过，毕竟只有一块电池，我希望充电宝可以充<br>而且我咋觉得mini的充电接口设计的有些奇怪，我可能孤陋寡闻了，真的感觉怪怪，不仅充电口奇怪，而且拔出来也很困难，主要我小心翼翼害怕弄坏</p>
<h4 id="精密的机械"><a href="#精密的机械" class="headerlink" title="精密的机械"></a>精密的机械</h4><p>DJI的风格偏向简约大气，所以提供的三根传输线，怎么不做成一根，岂不是更加简化，一根线上面插拔三个不同的头，只要一根线就可以了，三种不同种类的头是分别插拔上去的，感觉也不错。<br>我的小小飞是灰色的，看来是时候买个红色的贴纸了，以后小小飞也是经常可以换皮肤的。<br>螺旋桨貌似不可以快拆吧，如果螺旋桨也可以快拆就好了，就是不用螺丝刀随便拆那种，更方便，让我分分钟拆开再组装</p>
<h4 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h4><p>这种质量和配置，真的已经非常不容易了，我很佩服DJI的工程师，不同的产品定位不同的用户，想要高精度高配置的，移步其他系列。</p>
<p>最后我的第一次试飞体验，是心跳的感觉。<br>等我日后熟能生巧再来show我的小小飞吧</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>python之线程初级</title>
    <url>/posts/f5808ee4.html</url>
    <content><![CDATA[<h4 id="全局解释器锁-Global-Interpreter-Lock"><a href="#全局解释器锁-Global-Interpreter-Lock" class="headerlink" title="全局解释器锁(Global Interpreter Lock)"></a>全局解释器锁(Global Interpreter Lock)</h4><p>GIL是计算机程序设计语言解释器用于同步线程的工具（解释器级别）（Cpython）GIL能够保证同一时刻只有一个线程在运行</p>
<a id="more"></a>
<p>因此python解释器同时只能执行一个线程，即使多线程的环境，也只有一个线程能获得GIL，每个线程执行一段时间后释放GIL给其他线程使用，<br>python的多线程只能利用cpu的一个核，GIL会在IO调用前被释放，利于IO密集型任务，（当一个线程遇到I/O任务时会释放GIL，CPU密集型线程大约执行100次解释器的计步时，会释放GIL？？这个具体没有了解）<br>锁是为了应对多线程的数据同步问题，同样GIL也是，但是GIL和Lock是不同的锁（后期具体分析）</p>
<h4 id="如何创建一个线程"><a href="#如何创建一个线程" class="headerlink" title="如何创建一个线程"></a>如何创建一个线程</h4><h5 id="python里面的Thread类"><a href="#python里面的Thread类" class="headerlink" title="python里面的Thread类"></a>python里面的Thread类</h5><p>threading.Thread(target=None,name=Node,args=(),kwargs={},*,daemon=None)<br>#target表示run方法将要调用的对象，就是这个新线程的目标功能函数，不带小括号，默认none是不调用任何东西<br>#name是线程的名字，<br>#args是给要调用函数的参数元组，默认（）<br>#kwargs是给要调用目标的关键字参数的字典，默认{}<br>#daemon是否是守护线程<br>举例：threading.Thread(target=函数名)这个方法是创建一个线程，并给这个线程分配功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">threads=[]<span class="comment">#定义一个线程池</span></span><br><span class="line">t1 = threading.Thread(target=one)<span class="comment">#创建一个线程赋给t1，这个线程指定调用方法one，one是一个函数</span></span><br><span class="line">threads.append(t1)<span class="comment">#把线程t1装到线程池</span></span><br></pre></td></tr></table></figure>

<h5 id="三种创建线程的方法"><a href="#三种创建线程的方法" class="headerlink" title="三种创建线程的方法"></a>三种创建线程的方法</h5><p>1 创建线程实例，传给他一个函数，包括函数参数，这是常用方法，如上代码<br>2 创建线程实例，传给一个可调用的类实例，将调用<strong>call</strong>方法（不常用，但是更接近面向对象编程）<br>3 派生线程子类，创建子类的实例，必须重写run方法(必须继承threading.Thread这个父类)，这个run相当于方法1的线程函数，在start后会调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=<span class="string">'XX'</span>)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'XX'</span>, self.name)</span><br></pre></td></tr></table></figure>
<h5 id="线程开始运行"><a href="#线程开始运行" class="headerlink" title="线程开始运行"></a>线程开始运行</h5><p>thread.start()，启动新线程</p>
<h4 id="线程模块的基本方法"><a href="#线程模块的基本方法" class="headerlink" title="线程模块的基本方法"></a>线程模块的基本方法</h4><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p>threading.active_count()<br>返回当前活跃的Thread对象数量，返回值和通过enumerate（）返回的列表长度是相等（打印当前激活的线程数量，包含主线程）</p>
<p>threading.enumerate()<br>返回当前活跃的所有线程对象的列表，该列表包括守护线程，被current_thread()创建的虚拟线程对象和主线程，它不包括终止的线程和还没有启动的线程</p>
<p>threading.current_thread()获取当前线程，返回当前的thread对象，后面若加上.getName()则是获取当前线程名称<br>threading.current_thread().ident返回当前线程的id<br>threading.main_thread()返回主thread对象，在正常情况下，主线程是从python解释器中启动的线程<br>threading.getident()返回当前线程的线程标识符，线程启动后才有ID，否则为None，但是在线程退出后这个id可以再利用<br>thread.setName()给线程设置名称<br>Thread.is_alive()返回线程是否活着</p>
<h5 id="退出线程"><a href="#退出线程" class="headerlink" title="退出线程"></a>退出线程</h5><p>python中的线程没有优先级，不能被销毁、停止或者挂起，所以就没有恢复和中断，所以可以启动线程，但是却不能停止，线程自己在完成代码运行后会退出，或者可以调用thread.exit()可以退出，但是也不能像kill进程一样直接关闭<br>线程退出的两种情况：<br>1 线程函数内的语句执行完毕<br>2 线程函数中抛出未处理的异常</p>
<h5 id="join函数"><a href="#join函数" class="headerlink" title="join函数"></a>join函数</h5><p>join函数线程阻塞，设置在start之后，等所有阻塞线程运行完，再运行主线程(主线程被停止执行)，相当于把线程加入到当前线程，等加入的线程运行完成后，再继续运行当前线程<br>阻塞主线程必须在start方法之后执行，t.join()等线程t运行完再运行主线程<br>如果想让主线程等到子线程结束后再运行，就需要用到子线程.join(),这个是在start之后，与setDaemon相反<br>Thread.join(timeout)这个方法有个timeout参数，是线程超时时间设置，直至启动的线程之前一直挂起，除非给出timeout时间，否则一直阻塞，阻塞当前程序，直到Thread程序运行完成，如果设置timeout就是最多阻塞多少秒，没有设置，默认永久阻塞</p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p> _thread模块不支持守护线程，当主线程退出的时候，其他线程自动退出，不论是否在工作<br> threading模块支持守护线程，为子线程设置守护标记，当标记为true，thread.daemon = true，整个python程序会在所有非守护线程退出后才退出，</p>
<p>设置在start之前，设置子线程 A为守护线程，主线程所在的进程内所有非守护线程全部运行完毕，无论子线程A是否结束，程序都要结束<br>主线程退出时，不等到那些子线程完成，那么就设置子线程为守护线程，t1.setDaemon(True)，这个是设置守护线程，也可以使用thread.daemon = true这样可以检测数据合法性<br>如果设置一个线程为守护线程，就说明你这个线程不重要，在进程退出时，不用等待这个线程完成<br>如果程序不需要设置守护线程，就是等待所有子线程结束后才退出，不需要设置线程守护，或者显式调用t1.setDaemon(False)，这个是不设置守护线程<br>主线程是非守护线程，只要还存在一个非守护线程，程序就不会退出<br>一个新线程会继承父线程的守护标记</p>
<p>守护线程的应用场景：<br>1 后台任务，发送心跳包，监控<br>2 主线程工作才有用的线程，比如主线程中维护公共资源，主线程已经清理了，准备退出，而工作线程使用这些资源工作也没有意义，就会一起退出<br>3 随时可以被终止的线程<br>守护线程简化了程序员手动关闭线程的工作，如果主线程退出，想其他工作线程一起退出，就用守护线程创建工作线程，主线程退出，工作线程也没有必要存在，就会随着主线程的退出一起退出</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之正则表达式re</title>
    <url>/posts/d93670b5.html</url>
    <content><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>正则表达式regular expression是一种描述字符序列的方法，是用于处理字符串的强大工具，检查字符串是否与某种模式匹配，比如用来检查一个串是否含有某种子串，将匹配子串替换，或者从某个串中取出符合某个条件的子串，正则表达式是由普通字符例如字母（a-z）和特殊字符组成的文字模式</p>
<a id="more"></a>
<h5 id="表示数量的语法："><a href="#表示数量的语法：" class="headerlink" title="表示数量的语法："></a>表示数量的语法：</h5><h6 id><a href="#" class="headerlink" title="+"></a>+</h6><p> 123+4，可以匹配12334，1233334，123333334，其中+代表前一个字符必须至少出现一次（一次或多次）</p>
<h6 id="-1"><a href="#-1" class="headerlink" title="*"></a>*</h6><p>123<em>4，可以匹配124，123334，123334，</em>号表示前一个字符可以不出现，也可以出现一次或多次，是任何的意思</p>
<h6 id="？"><a href="#？" class="headerlink" title="？"></a>？</h6><p>123?4，可以匹配1234，124，？号表示前面的字符最多只可以出现一次（0次或1次）</p>
<h6 id="-2"><a href="#-2" class="headerlink" title=".*"></a>.*</h6><p>表示任意匹配除换行符（\n,\r）之外的任何单个或多个字符</p>
<h6 id="m"><a href="#m" class="headerlink" title="{m}"></a>{m}</h6><p>匹配前一个字符出现m次</p>
<h6 id="m-1"><a href="#m-1" class="headerlink" title="{m,}"></a>{m,}</h6><p>匹配前一个字符至少出现m次</p>
<h6 id="m-n"><a href="#m-n" class="headerlink" title="{m,n}"></a>{m,n}</h6><p>匹配前一个字符出现m到n次</p>
<h6 id="-3"><a href="#-3" class="headerlink" title="[]"></a>[]</h6><p>表示范围，比如[a-zA-Z0-9] 匹配一个字母或者数字</p>
<h6 id="a-zA-Z0-9"><a href="#a-zA-Z0-9" class="headerlink" title="[a-zA-Z0-9]*"></a>[a-zA-Z0-9]*</h6><p>匹配任意字母数字组成的字符串</p>
<h6 id="a-b"><a href="#a-b" class="headerlink" title="a|b"></a>a|b</h6><p> 匹配a或者b</p>
<h5 id="边界定位符："><a href="#边界定位符：" class="headerlink" title="边界定位符："></a>边界定位符：</h5><h6 id="-4"><a href="#-4" class="headerlink" title="^"></a>^</h6><p>匹配输入字符串开始的位置，</p>
<h6 id="-5"><a href="#-5" class="headerlink" title="$"></a>$</h6><p>匹配输入字符串结尾的位置</p>
<h6 id="b"><a href="#b" class="headerlink" title="\b"></a>\b</h6><p>匹配一个单词边界，即字与空格间的位置</p>
<h6 id="B"><a href="#B" class="headerlink" title="\B"></a>\B</h6><p>非单词边界匹配</p>
<h5 id="特殊字符类："><a href="#特殊字符类：" class="headerlink" title="特殊字符类："></a>特殊字符类：</h5><h6 id="-6"><a href="#-6" class="headerlink" title="."></a>.</h6><p>  匹配除\n之外的任何单个字符</p>
<h6 id="d"><a href="#d" class="headerlink" title="\d"></a>\d</h6><p> 匹配一个数字字符，等价于[0-9]</p>
<h6 id="D"><a href="#D" class="headerlink" title="\D"></a>\D</h6><p>匹配一个非数字字符，等价于[^0-9]</p>
<h6 id="w"><a href="#w" class="headerlink" title="\w"></a>\w</h6><p>可以匹配一个字母或者数字下划线</p>
<h6 id="W"><a href="#W" class="headerlink" title="\W"></a>\W</h6><p>非字母数字下划线，也就是上一个的相反情况</p>
<h4 id="python正则表达式"><a href="#python正则表达式" class="headerlink" title="python正则表达式"></a>python正则表达式</h4><p>re模块使python语言拥有全部的正则表达式功能,import re</p>
<h5 id="re-match"><a href="#re-match" class="headerlink" title="re.match"></a>re.match</h5><p>函数说明：从字符串的起始位置匹配一个模式，匹配成功返回一个匹配对象，否则返回none，通过group方法获取匹配的内容<br>函数语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.match(pattern, string, flags=<span class="number">0</span>) <span class="comment">#pattern要匹配的正则表达式，string要匹配的字符串，flags标志位</span></span><br></pre></td></tr></table></figure>
<h5 id="re-search"><a href="#re-search" class="headerlink" title="re.search"></a>re.search</h5><p>函数说明：扫描整个字符串并返回第一个成功的匹配,匹配成功返回一个匹配对象，否则返回none<br>函数语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.search(pattern, string, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，返回none，search匹配的是整个字符串，知道找到一个匹配</p>
<h5 id="re-sub"><a href="#re-sub" class="headerlink" title="re.sub"></a>re.sub</h5><p>函数说明：用于替换字符串中的匹配项<br>函数语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.sub(pattern, repl,string,count=<span class="number">0</span>,flags=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#pattern正则中的模式字符串</span></span><br><span class="line"><span class="comment">#repl替换的字符串，也可以为一个函数，前三个是必选参数</span></span><br><span class="line"><span class="comment">#count模式匹配后替换的最大次数，默认0表示替换所有匹配</span></span><br></pre></td></tr></table></figure>
<h5 id="re-complie"><a href="#re-complie" class="headerlink" title="re.complie"></a>re.complie</h5><p>函数说明：<br>compile函数用于编译正则表达式，生成一个正则表达式对象，供match和search函数使用。<br>compile根据一个模式字符串和可选的标志参数生成一个正则表达式对象，该对象拥有一系列方法用于正则表达式匹配和替换<br>函数用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.compile(pattern[, flags])<span class="comment">#flags是可选</span></span><br></pre></td></tr></table></figure>
<h5 id="re-findall"><a href="#re-findall" class="headerlink" title="re.findall"></a>re.findall</h5><p>函数说明：在字符串中找到正则所匹配的所有子串，并返回一个列表，如果没有找到匹配，则返回空列表<br>函数用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.findall(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure>
<h5 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer"></a>re.finditer</h5><p>函数说明：在字符串中找到正则所匹配的所有子串，并把他们作为一个迭代器返回<br>函数用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.finditer(pattern, string,flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h5 id="re-split"><a href="#re-split" class="headerlink" title="re.split"></a>re.split</h5><p>函数说明：按照能够匹配的子串将字符串分割后返回列表<br>函数用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.split(pattern,string[,maxsplit=<span class="number">0</span>,flags=<span class="number">0</span>])<span class="comment">#maxsplit分隔次数，1代表分隔一次，默认0，不限制次数</span></span><br></pre></td></tr></table></figure>
<h5 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h5><p>python中的正则表达式修饰符，多个标志位可以通过按位OR｜来指定</p>
<h6 id="re-I"><a href="#re-I" class="headerlink" title="re.I"></a>re.I</h6><p>ignorecase 使匹配对大小写不敏感</p>
<h6 id="re-L"><a href="#re-L" class="headerlink" title="re.L"></a>re.L</h6><p>locale 做本地化识别匹配,即特殊字符集以来当前环境</p>
<h6 id="re-M"><a href="#re-M" class="headerlink" title="re.M"></a>re.M</h6><p>Multiline 多行匹配，影响^和$</p>
<h6 id="re-S"><a href="#re-S" class="headerlink" title="re.S"></a>re.S</h6><p> 使.匹配包括换行在内的所有字符</p>
<h6 id="re-U"><a href="#re-U" class="headerlink" title="re.U"></a>re.U</h6><p> 根据Unicode字符集解析字符，会影响\w,\W,\b,\B</p>
<h6 id="re-X"><a href="#re-X" class="headerlink" title="re.X"></a>re.X</h6><p>通过给予更灵活的格式，以便似的正则表达式更加易于理解</p>
<h5 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h5><p>正则表达式的强大功能就是提取子串，用（）表示要提取的分组<br>如果正则表达式中定义了组，可以在match对象上用group（）方法提取子串，其中group(0)是代表原始字符串group(1)group(2)依次表示第一个子串，第二个子串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = <span class="string">'date 2019-12-20'</span></span><br><span class="line">res = re.search(<span class="string">r'(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)'</span>, test)</span><br><span class="line">res.group()<span class="comment">#'2019-12-20'</span></span><br><span class="line">res.group(<span class="number">1</span>)<span class="comment">#'2019'</span></span><br></pre></td></tr></table></figure>
<p>使用名称提取分组，形式：(?P<name>)</name></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = <span class="string">'date 2019-12-20'</span></span><br><span class="line">res = re.search(<span class="string">r'(?P&lt;year&gt;\d&#123;4&#125;)-(?P&lt;mon&gt;\d&#123;2&#125;)-(?P&lt;day&gt;\d&#123;2&#125;)'</span>, test)</span><br><span class="line">res.group(<span class="string">'year'</span>)<span class="comment">#'2019'</span></span><br></pre></td></tr></table></figure>
<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>当我们使用正则表达式时，re模块内部会做两件事情<br>第一是编译正则表达式，如果正则表达式的字符串本身不合法，会报错<br>第二是用编译后的正则表达式去匹配字符串<br>一个正则表达式如果要重复使用多次，比如几千次，那出于效率的角度，可以先预编译正则表达式，这样使用的时候就不用编译这个步骤了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">res = re.compile(<span class="string">r'(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)'</span>)</span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">res.match(<span class="string">'2019-12-20'</span>).groups()</span><br></pre></td></tr></table></figure>

<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>匹配任意电子邮箱：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.match(<span class="string">r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9_-]+\.[a-zA-Z]+$'</span>, <span class="string">'aaaaaaaa@gmail.com'</span>):</span><br></pre></td></tr></table></figure>
<p>匹配任意电话号码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.match(<span class="string">r'^\d&#123;3&#125;\-\d&#123;3,8&#125;$'</span>, <span class="string">'010-12345'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过使用正则表达式，可以：<br><strong>测试字符串内的模式</strong><br>可以测试输入字符串，以查看字符串内是否出现电话号码或者信用卡号码</p>
<p><strong>替换文本</strong><br>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换</p>
<p><strong>从字符串中提取子字符串</strong><br>可以查找文档内或者输入域内特定的文本</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之lambda表达式</title>
    <url>/posts/863e37ea.html</url>
    <content><![CDATA[<h4 id="什么是lambda"><a href="#什么是lambda" class="headerlink" title="什么是lambda"></a>什么是lambda</h4><p>python中的关键字lambda是定义匿名函数用的，返回的是函数类型（一个新函数）</p>
<a id="more"></a>
<p>问题一：何为匿名函数？<br>匿名函数就是不需要函数名的函数<br>问题二：匿名函数和def函数体有什么区别？<br>def创建的方法是有具体函数名称的，匿名函数没有具体的函数名称，详见后文<br>问题三：lambda表达式的优点<br>既然是表达式，那就是只有一行的函数，因此代码更加简洁。尤其当函数作为参数的时候，lambda非常有用，很简洁</p>
<h4 id="lambda的形式"><a href="#lambda的形式" class="headerlink" title="lambda的形式"></a>lambda的形式</h4><p>在lambda语句中，冒号前是函数参数，可以有多个，用逗号隔开，如果没有则省略。冒号右边是返回值，lambda语句构建的是一个函数对象，如果将这个函数对象保存在变量中，再次使用变量时，使用这个引用变量就相当于使用函数对象，可以供其他函数调用，例如可以直接func(x)这样使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">func = <span class="keyword">lambda</span> x : x*x    <span class="comment">#lambda表达式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span>      <span class="comment">#普通函数</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br></pre></td></tr></table></figure>

<h4 id="lambda的应用"><a href="#lambda的应用" class="headerlink" title="lambda的应用"></a>lambda的应用</h4><h5 id="filter函数"><a href="#filter函数" class="headerlink" title="filter函数"></a>filter函数</h5><p>用法：filter(None或者lambda表达式，变量)<br>作用：将可迭代的数据中经过条件筛选出结果为1或者结果为true的数据，结合lambda使用非常方便.<br>filter的第一个参数为None时，就会获取到原来的序列，记住不是省略，而是None</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#筛选出1-10之间的奇数</span></span><br><span class="line">mylist = list(filter(<span class="keyword">lambda</span> x : x%<span class="number">2</span>, range(<span class="number">0</span>,<span class="number">10</span>))) </span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h5 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h5><p>用法：map(lambda表达式，要操作序列)<br>作用：遍历序列，对序列中的每个元素进行操作，最终获得新的序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">new_list = map(<span class="keyword">lambda</span> x : x+<span class="number">10</span>, list)</span><br></pre></td></tr></table></figure>

<h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p>用法：reduce(lambda表达式，要循环的队列，初始值)，函数必须要有两个参数<br>作用：对序列内所有的元素进行累计操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x,y : x+y,list)</span><br></pre></td></tr></table></figure>

<p>4 不使用lambda的情况<br>lambda其实只是一个表达式，所以他能够取代的函数逻辑有限。<br>如果一个列表生成式仅使用for，if ，in就能实现，那就不需要使用lambda<br>如果函数逻辑十分复杂，那么就会定义函数，让代码更具有可读性，也不需要使用lambda</p>
<p>当你只需要一个简单的单行函数做一件简单的事情，甚至有时我们连函数的名字都不需要知道，那么此时的lambda就是一个不错的选择，毕竟不用冥思苦想函数名称用啥了，也不用担心命名冲突。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>git理解</title>
    <url>/posts/12950bc2.html</url>
    <content><![CDATA[<h3 id="什么是git"><a href="#什么是git" class="headerlink" title="什么是git"></a>什么是git</h3><p>git是一个C语言编写分布式版本控制系统。不需要中央服务器，不需要联网</p>
<a id="more"></a>

<p>对应的是：集中式的版本控制系统是需要中央服务器的，版本库是放在中央服务器的，而分布式的版本控制的优点就是没有中央服务器，每个电脑都是一个完整的版本库。这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上</p>
<p>类似系统CVS、SVN、Perforce都是集中式版本控制系统，分布式系统有Git, Mercurial、Bazaar、Darcs、FOssil等</p>
<h3 id="Git管理的是文件的修改，而不是文件"><a href="#Git管理的是文件的修改，而不是文件" class="headerlink" title="Git管理的是文件的修改，而不是文件"></a>Git管理的是文件的修改，而不是文件</h3><p>所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动。</p>
<p>而对于图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>所以Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p>
<h3 id="为什么Git添加文件需要add，commit一共两步呢？"><a href="#为什么Git添加文件需要add，commit一共两步呢？" class="headerlink" title="为什么Git添加文件需要add，commit一共两步呢？"></a>为什么Git添加文件需要add，commit一共两步呢？</h3><img src="/posts/12950bc2/add.png" class title="add">

<p>add是将修改提交到暂存区，commit是把暂存区的内容推送到代码仓库</p>
<p>因为commit可以一次提交很多文件，所以你可以多次add不同的文件 commit后面的参数-m是本次提交的说明，输入说明对阅读很重要</p>
<p><strong>关于修改</strong><br>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit<br>每次修改都要add到暂存区，最后才会commit</p>
<p><strong>那为什么要有暂存区呢？</strong></p>
<p>为了保证提交的原子性，让提交颗粒度分明</p>
<h3 id="工作区，暂存区，版本库"><a href="#工作区，暂存区，版本库" class="headerlink" title="工作区，暂存区，版本库"></a>工作区，暂存区，版本库</h3><p>工作区相当于你电脑的工程文件夹，里面有一个.git的隐藏目录，是git的版本库，版本库包括两部分，一部分是add后的暂存区，一部分是commit后的代码仓库</p>
<img src="/posts/12950bc2/repositary.png" class title="reposirary">

<p>在Git中，用HEAD表示当前工作的分支，也就是最新的提交1094adb…，上一个版本就是HEAD^，上上一个版本就是HEAD^^，100版本写成HEAD~100。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>git的简单命令</title>
    <url>/posts/f99dd8d6.html</url>
    <content><![CDATA[<p>Git 有几个概念哈，工作区，暂存区，版本库</p>
<a id="more"></a>
<p>首先对一个文件夹进行git初始化: git init，会生成一个.git文件，这就是版本库，git会自动在版本库里创建一个master分支和一个暂存区</p>
<p><strong>工作区</strong>：该文件夹</p>
<p><strong>版本库</strong>：整个.git文件夹</p>
<p><strong>暂存区</strong>：版本库的一部分（另一部分是master分支）</p>
<p><strong>远程仓库</strong>：github上的master分支</p>
<p><strong>git add xxx</strong></p>
<p>把修改的文件添加到暂存区</p>
<p><strong>git commit -m  “”</strong></p>
<p>把暂存区里所有的文件提交到master分支</p>
<p><strong>git remote url</strong> </p>
<p>将本地的版本库关联到远程仓库</p>
<p><strong>git push</strong></p>
<p>把本地版本库master分支里的内容提交到到远程github的master分支</p>
<p><strong>git pull</strong></p>
<p>从远程github的master分支更新本地版本库的master分支</p>
<p><strong>git clone url</strong></p>
<p>从远程仓库克隆到本地某处</p>
<h6 id="创建一个新的仓库"><a href="#创建一个新的仓库" class="headerlink" title="创建一个新的仓库"></a>创建一个新的仓库</h6><ol>
<li>点主页的绿色NEW</li>
<li>命名，跟本地文件夹名字相同（下面的框框不要勾选）</li>
<li>命令行进入本地文件夹 cd进入</li>
<li>git init</li>
<li>git add .</li>
<li>git commit -m “first commit”</li>
<li>git remote add origin URL (origin后面跟的url是刚创建完那个页面的url，复制过来)</li>
<li>git push -u origin master</li>
<li>完成</li>
</ol>
<h6 id="本地修改git"><a href="#本地修改git" class="headerlink" title="本地修改git"></a>本地修改git</h6><ol>
<li>git add .</li>
<li>git commit -m “名字”</li>
<li>git push</li>
</ol>
<h6 id="Git鼓励大量使用分支："><a href="#Git鼓励大量使用分支：" class="headerlink" title="Git鼓励大量使用分支："></a>Git鼓励大量使用分支：</h6><ol>
<li>查看分支：git branch</li>
<li>创建分支：git branch <name></name></li>
<li>切换分支：git checkout <name></name></li>
<li>创建+切换分支：git checkout -b <name></name></li>
<li>合并某分支到当前分支：git merge <name></name></li>
<li>删除分支：git branch -d <name></name></li>
</ol>
<h6 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h6><p>git diff顾名思义就是查看difference</p>
<p>git status命令可以让我们时刻掌握仓库当前的状态</p>
<p>git reset版本回退</p>
<p>git log –author=”author”查看某人提交的版本</p>
<p>git log –stat查看提交历史</p>
<p>git checkout -b dev//创建并切换分支</p>
<p>git merge <name>//合并某分支到当前的分支</name></p>
<p>git branch -d <name>//删除分支</name></p>
<p>git blame filename可以查看文件修改的详细信息，谁修改了哪些内容，看到提交时间以及作者，适合团队合作，看到文件的各个区域的最近提交的人是谁</p>
<h6 id="使用git在团队中的协作"><a href="#使用git在团队中的协作" class="headerlink" title="使用git在团队中的协作"></a>使用git在团队中的协作</h6><ol>
<li>整个团队的最终分支是master</li>
<li>然后每个开发都有一个dev的开发分支</li>
<li>每个人都从master拉下一个属于自己的开发分支</li>
<li>开发完成后要进行更改操作，就是提交，要输入有意义的提交信息</li>
<li>找到自己的代码，右键暂存，就会放到暂存区,然后提交，同步</li>
<li>然后在git的远程网站中点击合并请求，如果没有就创建一个merge request</li>
<li>点击右上角的creat Merge Request</li>
<li>创建的时候要选源分支，就是自己的分支，还要选你要合并到的分支，比如master</li>
<li>选择代码审查人，审查结束就等待审查结果</li>
<li>发现有discussion然后解决，解决之后就可以让审查人将代码合并</li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>python之文件和异常</title>
    <url>/posts/f8bc5ee8.html</url>
    <content><![CDATA[<h4 id="从文件读取数据"><a href="#从文件读取数据" class="headerlink" title="从文件读取数据"></a>从文件读取数据</h4><h5 id="读取整个文件"><a href="#读取整个文件" class="headerlink" title="读取整个文件"></a>读取整个文件</h5><a id="more"></a>

<p>首先需要打开文件，使用函数open()打开文件，参数为要打开文件的名称(或者相对文件路径或绝对文件路径），pyhton在当前执行的文件所在的目录中查找指定的文件，因此要打开的文件应该放在当前文件的目录里。函数open返回一个表示文件的对象，将这个对象存在file_object中。（还记得C++打开文件的文件指针吗）</p>
<p>with关键字在不再需要访问文件后将其关闭，这比直接使用close函数要好，因为1 如果程序出现bug，导致close语句未执行，文件就不会关闭。2 过早的调用了close，后面再使用文件时就会出现错误（无法访问），所以不能很好的确定关闭文件的正确时机，使用with可以让python自己判断自动再合适的时机关闭</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"要打开文件的名称"</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">     contents = file_object.read() <span class="comment">#拥有文件对象后，调用read方法</span></span><br><span class="line">     print(contents)    <span class="comment">#print(contents.rstrip())删除空行</span></span><br></pre></td></tr></table></figure>

<p>打印结果会多一个空行，因为read函数到达文件末尾时返回一个空字符串，将这个空字符串显示出来就是一个空行，要删除多余的空行，使用rstrip()<br><strong>ATTENTION：在使用文件路径时，OS和linux采用/斜杠，windows采用\反斜杠</strong></p>
<h5 id="逐行读取"><a href="#逐行读取" class="headerlink" title="逐行读取"></a>逐行读取</h5><p>使用for循环遍历文件中的每一行，同样直接打印的话，每一行都有一个换行符，使用rstrip删除空行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"要打开文件的名称"</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">     <span class="keyword">for</span> line <span class="keyword">in</span> file_object：</span><br><span class="line">     print(line)    <span class="comment">#print(line.rstrip())删除空行</span></span><br></pre></td></tr></table></figure>

<h5 id="创建一个包含文件各行内容的列表"><a href="#创建一个包含文件各行内容的列表" class="headerlink" title="创建一个包含文件各行内容的列表"></a>创建一个包含文件各行内容的列表</h5><p>使用with关键字时，open返回的文件对象只在with代码中使用，如果想在with代码块外访问文件内容，可以在with代码块内将文件的各行存储在一个列表中，这样就可以在代码块外使用这个列表了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"要打开文件的名称"</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines() <span class="comment">#从文件中读取每一行，并把它存储在一个列表中</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    print(line.rstrip())</span><br></pre></td></tr></table></figure>


<h5 id="使用文件内容"><a href="#使用文件内容" class="headerlink" title="使用文件内容"></a>使用文件内容</h5><p>使用文本文件时，pyhton将其中的所有文本解读成字符串，如果读取的是数字，需要作为数值使用，就必须使用int函数将其转换为整数或者float将其转化为浮点数</p>
<h5 id="f-readline-vs-f-readlines"><a href="#f-readline-vs-f-readlines" class="headerlink" title="f.readline() vs f.readlines()"></a>f.readline() vs f.readlines()</h5><p>readlines一次读入所有数据进内存，readline一行一行读，大数据用readline</p>
<h5 id="io模块和codecs模块可以指定编码，读取中文文件需要指定utf-8编码："><a href="#io模块和codecs模块可以指定编码，读取中文文件需要指定utf-8编码：" class="headerlink" title="io模块和codecs模块可以指定编码，读取中文文件需要指定utf-8编码："></a>io模块和codecs模块可以指定编码，读取中文文件需要指定utf-8编码：</h5><p>import io<br>io.readlines(filename, ‘r’, encoding=’utf-8’)</p>
<h5 id="读取二进制文件"><a href="#读取二进制文件" class="headerlink" title="读取二进制文件"></a>读取二进制文件</h5><p>f.readline(filename, ‘rb’)</p>
<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><h5 id="写入空文件"><a href="#写入空文件" class="headerlink" title="写入空文件"></a>写入空文件</h5><p>调用open函数提供两个实参，第一个是要打开文件的名称，第二个是以写入模式(‘w’)打开文件，另外还有读取模式(‘r’)附加模式(‘a’)以及这几种的混合模式，，省略第二个实参默认只读模式打开文件，如果写入文件不存在，open函数会自动创建。以写入模式打开文件需要注意，如果指定文件已经存在，python将在返回文件对象前清空该文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">     file_object.write(<span class="string">"I love programming"</span>)</span><br></pre></td></tr></table></figure>
<p>注意：python只能将字符串写入文本文件，要将数值数据存储到文本文件中，必须使用函数str()将其转化为字符串格式</p>
<h5 id="写入多行"><a href="#写入多行" class="headerlink" title="写入多行"></a>写入多行</h5><p>函数write()不会在写入的文本末尾添加换行符，因此写入多行时会挤到一起，因此在write语句中增加换行符，保证文件中的内容能够显示在不同行</p>
<h5 id="附加到文件"><a href="#附加到文件" class="headerlink" title="附加到文件"></a>附加到文件</h5><p>以附加方式打开文件，python不会在返回文件对象前清空文件，写入文件的行都将添加到文件末尾，是给文件添加内容，而不是覆盖原有的内容，如果文件不存在将创建一个空文件</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>每当发生python错误时，都会创建一个异常对象，如果不对异常进行处理，程序就会停止，并显示一个traceback。异常是使用try-except代码块处理的。</p>
<h5 id="处理ZeroDivisionError异常"><a href="#处理ZeroDivisionError异常" class="headerlink" title="处理ZeroDivisionError异常"></a>处理ZeroDivisionError异常</h5><p>对除0异常进行处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="number">5</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">"U cannt divide by zero"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="处理FileNotFoundError异常"><a href="#处理FileNotFoundError异常" class="headerlink" title="处理FileNotFoundError异常"></a>处理FileNotFoundError异常</h5><p>使用文件时，找不到文件就会出现FileNotFoundError异常，这是python找不到要打开的文件时创建的异常，这个错误时open函数导致的，要处理这个错误，必须把try放到包含open函数的代码行之前。</p>
<h5 id="pass语句什么都不做"><a href="#pass语句什么都不做" class="headerlink" title="pass语句什么都不做"></a>pass语句什么都不做</h5><p>正确的使用异常很多时候也靠项目经验，但是正确处理异常现象非常重要，比如上面打开文件的错误异常，在实际项目中严谨的代码是要处理这个异常的。尽量编写优雅的代码，经过详尽测试的不容易出现内部错误的代码，丰富的项目经验可以让我们判断出程序在哪里会出现异常以及出现错误时应该向用户提供哪些相关信息</p>
<h5 id="其他异常"><a href="#其他异常" class="headerlink" title="其他异常"></a>其他异常</h5><p>NameError —–尝试访问一个没有申明的变量<br>SyntaxError——语法错误<br>IndexError ——索引超出序列范围<br>KeyError ——请求一个不存在的字典关键字<br>AttributeError—–尝试访问未知的对象属性<br>ModeuleNotFoundError—–模块未发现<br>IndetationError —–缩进错误</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之迭代器、生成器</title>
    <url>/posts/6d39ca9a.html</url>
    <content><![CDATA[<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代是访问集合元素的方式之一，除了迭代器外还可以通过下标运算符来访问</p>
<a id="more"></a>
<h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>迭代器是一个可以记住遍历位置的对象，迭代器的对象从集合的第一个元素访问，直到所有元素被访问结束，迭代器只能往前不能后退。基本方法是iter()和next()<br>字符串、列表和元组都可以创建迭代器。注意：可迭代对象还有处于打开状态的files，sockets</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = iter(list)<span class="comment">#创建迭代器</span></span><br><span class="line">print(next(it))<span class="comment">#输出迭代器的下一个元素</span></span><br></pre></td></tr></table></figure>

<p>迭代器内部有一个状态，这个状态是用于记录当前迭代的位置，以便下次迭代的时候获取正确的元素</p>
<h5 id="迭代器对象可以使用常规的for语言遍历或者next函数"><a href="#迭代器对象可以使用常规的for语言遍历或者next函数" class="headerlink" title="迭代器对象可以使用常规的for语言遍历或者next函数"></a>迭代器对象可以使用常规的for语言遍历或者next函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = iter(list)<span class="comment">#创建迭代器</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    print(x)</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">import</span> sys <span class="comment">#引入sys模块</span></span><br><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = iter(list)<span class="comment">#创建迭代器</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(next(it))</span><br><span class="line"><span class="keyword">except</span> StopIteration:<span class="comment">#该异常用于标识迭代的完成，防止出现无限循环情况</span></span><br><span class="line"> sys.exit()</span><br></pre></td></tr></table></figure>
<h5 id="把类作为迭代器使用"><a href="#把类作为迭代器使用" class="headerlink" title="把类作为迭代器使用"></a>把类作为迭代器使用</h5><p>把类作为迭代器使用需要实现两个方法<em>iter</em>()和<em>next</em>()，看到这两个方法的形式，你还记得前面学过的<em>init</em>()吗（用于初始化）<br><em>iter</em>()函数返回一个特殊的迭代器对象，这个对象实现了<em>next</em>()方法并通过StopIteration异常标识迭代的完成。<br><em>next</em>()方法会返回下一个迭代器对象,如果容器中没有更多的元素了，则抛出异常。<br>创建一个返回数字的迭代器，初始值为1，逐步增加1，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Class Getnumber:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_iter_</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_next_</span><span class="params">(self)</span>:</span></span><br><span class="line">        x = self.a</span><br><span class="line">        self.a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">getnumber = Getnumber()</span><br><span class="line">myiter = iter(getnumber)</span><br><span class="line"></span><br><span class="line">print(next(myiter))  </span><br><span class="line">print(next(myiter))</span><br></pre></td></tr></table></figure>

<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><p>使用了yield的函数称为生成器，生成器是一个返回迭代器的函数（一个特殊的迭代器），只能用于迭代操作，返回数据时会使用yield语句，不需要上面两个方法了。<br>在调用生成器运行的过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值，并在下一次执行next方法时从当前位置继续运行。<br>调用一个生成器函数，返回是一个迭代器对象（不需要return了）。</p>
<h5 id="对比是否用yield实例"><a href="#对比是否用yield实例" class="headerlink" title="对比是否用yield实例"></a>对比是否用yield实例</h5><p>使用yield斐波那契</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n, w = <span class="number">0</span>)</span>:</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span>(counter &gt; n):</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">       print(<span class="string">'%d, %d'</span> %(a, b))</span><br><span class="line">       counter += <span class="number">1</span></span><br><span class="line">   f = fibonacci(<span class="number">10</span>,<span class="number">0</span>) <span class="comment"># f是一个由生成器返回的迭代器         </span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">    print(next(f), end = <span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">except</span> :</span><br><span class="line">    sys.exit()</span><br></pre></td></tr></table></figure>


<p>不使用yield斐波那契，（注释掉yield）函数只是简单执行，没有返回迭代器f</p>
<img src="/posts/6d39ca9a/%E4%B8%8D%E4%BD%BF%E7%94%A8yield.png" class title="不使用yield">

<h5 id="什么情况需要使用yield"><a href="#什么情况需要使用yield" class="headerlink" title="什么情况需要使用yield"></a>什么情况需要使用yield</h5><p>划重点减少大内存的使用，举例：当我们调用函数返回一个很大的list时，一般情况是得到一个很大的list之后再去使用，这样就会非常占用内存，但是实际上我们使用的是list的遍历（list的迭代器），不需要得到完整的list，所以我们可以让这个函数每次只返回一个迭代器的一个计算结果，这个时候yield就很有用。<br>使用生成器不仅可以节省内存和CPU，还可以用更少的代码实现相似的功能</p>
<p>题外话：还记得C++如何优化斐波那契求解，传统的C++求解斐波那契会递归很多次，产生递归栈，最后因为栈溢出崩溃，优化递归部分以解决重复计算问题，优化算法，从下往上计算，根据f(0),f(1)得到f(2),再有f(1)和f(2)得到f(3)</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之装饰器和闭包</title>
    <url>/posts/33412124.html</url>
    <content><![CDATA[<p>装饰器与闭包的学习</p>
<a id="more"></a>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="初识装饰器"><a href="#初识装饰器" class="headerlink" title="初识装饰器"></a>初识装饰器</h3><p>装饰器(decorator)实际上是一个函数，用来改变其他函数的功能，如果我们有一个函数，功能为打印一句话<br>本文的代码格式炸了，我也很无力，明明是对的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">"hello, I am f1."</span>)</span><br></pre></td></tr></table></figure>

<p>现在我们需要改变打印的内容，但是不能修改此函数中的打印语句，那么我们可以添加一个函数，修改f1这个引用指向的对象为新的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">			print(<span class="string">"hello, I am NOT f1."</span>)</span><br><span class="line">	<span class="keyword">return</span> inner</span><br><span class="line">f1 = decorator(f1)</span><br></pre></td></tr></table></figure>

<p>运行f1，得到的结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line">hello, I am NOT f1.</span><br></pre></td></tr></table></figure>

<p>可以看到，我们成功地改变了原函数的打印语句，上面的decorator函数即为python中的<strong>装饰器</strong>，我们可以使用语法糖@将上面的python代码简化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">"hello, I am f1."</span>)</span><br></pre></td></tr></table></figure>



<h3 id="Python何时执行装饰器"><a href="#Python何时执行装饰器" class="headerlink" title="Python何时执行装饰器"></a>Python何时执行装饰器</h3><p>装饰器在模块导入时即执行，而不是显示调用被装饰的函数时才执行，下面我们来看一个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">  	print(<span class="string">'running register(%s)'</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">		<span class="keyword">return</span> func</span><br><span class="line">  </span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'running f1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'running f2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  	f1()</span><br><span class="line">    f2()</span><br></pre></td></tr></table></figure>

<p>如果上面的py文件当做脚本运行，那么可以得到结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">running register(&lt;function f1 at <span class="number">0x100f962a8</span>&gt;)</span><br><span class="line">running register(&lt;function f2 at <span class="number">0x100f961b8</span>&gt;)</span><br><span class="line">running f1</span><br><span class="line">running f2</span><br></pre></td></tr></table></figure>

<p>如果是当做模块导入，那么结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">running register(&lt;function f1 at <span class="number">0x100f962a8</span>&gt;)</span><br><span class="line">running register(&lt;function f2 at <span class="number">0x100f961b8</span>&gt;)</span><br></pre></td></tr></table></figure>

<p>这也证实了装饰器在模块导入时运行</p>
<h3 id="装饰器的功能"><a href="#装饰器的功能" class="headerlink" title="装饰器的功能"></a>装饰器的功能</h3><p>从上面的例子可以看到，我们可以将工程中的register函数定义为装饰器，其他功能函数在使用之前必须要经过装饰器注册后才能使用，在需要临时取消某些函数功能时，只需要去掉语法糖”@”即可，功能强大且非常灵活、</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">  	print(<span class="string">'running register(%s)'</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">		<span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用f1</span></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'running f1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用f2</span></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'running f2'</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 禁用f3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'running f3'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">manager</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">for</span> func <span class="keyword">in</span> registry:</span><br><span class="line">    	<span class="string">"""do something"""</span></span><br><span class="line">    	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，f1和f2两个功能函数启用，f3被禁用，manager函数实现对所有启用的函数进行操作。</p>
<h3 id="Python变量的作用域"><a href="#Python变量的作用域" class="headerlink" title="Python变量的作用域"></a>Python变量的作用域</h3><p>python变量遵循”LEGB”原则，L(local)，E(enclosing)，G(global)，B(built-in)，即解释器在寻找变量时，会现在函数内部(local)里寻找，如果找不到，去外层函数(enclosing)中寻找，最后去全局变量(global)和内建(built-in)中寻找，下面看一个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a)</span>:</span></span><br><span class="line">  	print(a)</span><br><span class="line">    print(b)</span><br><span class="line">f1(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>显然，最终的输出结果为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这是因为解释器把b当做了全局变量打印，现在我们稍作修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a)</span>:</span></span><br><span class="line">  	print(a)</span><br><span class="line">  	b = <span class="number">3</span></span><br><span class="line">    print(b)</span><br><span class="line">f1(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>现在的输出结果为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>现在的变量b是局部(local)变量，解释器优先在local里寻找，而不是global，我们再加修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a)</span>:</span></span><br><span class="line">  	print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    b = <span class="number">3</span></span><br><span class="line">f1(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">UnboundLocalError: local variable <span class="string">'b'</span> referenced before assignment</span><br></pre></td></tr></table></figure>

<p>这是因为此时的b在编译阶段被确认为局部变量，但是我们未经赋值就进行使用，所以会报错！</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>Python从入门到实践习题参考</title>
    <url>/posts/5c354b05.html</url>
    <content><![CDATA[<p>好记性不如烂笔头，虽然习题简单，还是需要操作的<br>如下：<a href="https://github.com/TristaWWP/Python-programming-reference-/tree/master" target="_blank" rel="noopener">Python从入门到实践习题参考</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python入门之条件、循环、函数、模块</title>
    <url>/posts/1598b31a.html</url>
    <content><![CDATA[<p>python的简单了解，关于条件、循环、函数和模块，本文均为基础知识</p>
<a id="more"></a>

<h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><p>C++:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件):</span><br><span class="line">    执行代码</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(条件):</span><br><span class="line">    执行代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    执行代码</span><br></pre></td></tr></table></figure>

<p>python：不需要括号，并且第二个为elif</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件：</span><br><span class="line">    执行代码</span><br><span class="line"><span class="keyword">elif</span> 条件：</span><br><span class="line">    执行代码</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    执行代码</span><br></pre></td></tr></table></figure>

<p>C++用{}表示一个程序块，python代码结构由：和 缩进表示同为一个程序块<br>python中检查多个条件是否为true用and连接（类比C++中&amp;&amp;）<br>检查是否有一个相等or（类比||）<br>检查是否包含在列表中使用in，不包含使用not in</p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>C++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)<span class="comment">//用n控制循环</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range://采用序列的方式控制循环</span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><p>关键字def定义一个函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""显示简单的问候语"""</span><span class="comment">#该行为docstring，文档字符串的注释，描述函数做什么的</span></span><br><span class="line">    print(<span class="string">"hello"</span>)     <span class="comment">#该行为函数体</span></span><br></pre></td></tr></table></figure>

<h5 id="传递实参"><a href="#传递实参" class="headerlink" title="传递实参"></a>传递实参</h5><ul>
<li><p>位置实参：实参和形参的传递顺序相同，就是类似普通的参数传递</p>
</li>
<li><p>关键字实参：在实参中将名称和值关联起来，这样在传递的过程不会混淆,无序考虑函数调用中的实参顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span><span class="params">(animal_type, pet_name)</span>:</span></span><br><span class="line">    XXXXXXX</span><br><span class="line">describe_pet(animal_type=<span class="string">'hamster'</span>, pet_name=<span class="string">'harry'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认值，给形参指定默认值，使用默认值时，在形参列表中必须先列出没有默认值的形参，再列出有默认值的实参。这让Python依然能够正确地解读位置实参</p>
</li>
</ul>
<h5 id="禁止函数修改列表"><a href="#禁止函数修改列表" class="headerlink" title="禁止函数修改列表"></a>禁止函数修改列表</h5><p>方法：向函数传递列表的副本而不是原件，这样函数的任何修改都只是影响副本，不影响原件。切片表示法[:]是创建列表的副本。<br><code>function_name(list_name[:]) #传递列表的副本</code></p>
<p>BUT一般还是要传递原始列表给函数，因为原始列表可以避免花费时间和内存创建副本，从而提高效率，处理大型列表更要如此。</p>
<h5 id="传递任意数量的实参"><a href="#传递任意数量的实参" class="headerlink" title="传递任意数量的实参"></a>传递任意数量的实参</h5><p>形参名 * XXX中的 * 是创建一个名为XXX的空元组，并把收到的所有值都封装到这个元组中。注意：python将实参封装到一个元组中，即便函数只收到一个值也是如此。** XXX中的** 是创建一个空字典，这样就可以使用关键字形参了（键值对形式）</p>
<h5 id="函数接受任意数量的实参和位置实参混合使用"><a href="#函数接受任意数量的实参和位置实参混合使用" class="headerlink" title="函数接受任意数量的实参和位置实参混合使用"></a>函数接受任意数量的实参和位置实参混合使用</h5><p>要把接受任意数量的实参的形参放在最后，函数接收参数时，先匹配位置实参和关键字实参，最后再将余下实参都放到最后一个形参中。</p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>模块是扩展名为.py的文件，包含要导入到程序的代码。一般将函数存储在模块的独立文件中，再将模块导入到主程序中</p>
<h5 id="直接导入模块"><a href="#直接导入模块" class="headerlink" title="直接导入模块"></a>直接导入模块</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module_name</span><br><span class="line">mudule_name.func   <span class="comment">#调用函数方法</span></span><br></pre></td></tr></table></figure>

<h5 id="导入特定函数"><a href="#导入特定函数" class="headerlink" title="导入特定函数"></a>导入特定函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> func_1,func_2.......</span><br><span class="line">func_1() <span class="comment">#直接调用函数</span></span><br></pre></td></tr></table></figure>

<h5 id="使用as给函数起别名，防止命名冲突或函数名太长，也可用as给模块指定别名，方法同前"><a href="#使用as给函数起别名，防止命名冲突或函数名太长，也可用as给模块指定别名，方法同前" class="headerlink" title="使用as给函数起别名，防止命名冲突或函数名太长，也可用as给模块指定别名，方法同前"></a>使用as给函数起别名，防止命名冲突或函数名太长，也可用as给模块指定别名，方法同前</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> func <span class="keyword">as</span> ff</span><br><span class="line">ff() <span class="comment">#直接使用函数的别名</span></span><br></pre></td></tr></table></figure>

<h5 id="使用-带入模块中的所有函数-不过如果不是自己写的大型模块，尽量不用"><a href="#使用-带入模块中的所有函数-不过如果不是自己写的大型模块，尽量不用" class="headerlink" title="使用*带入模块中的所有函数,不过如果不是自己写的大型模块，尽量不用"></a>使用*带入模块中的所有函数,不过如果不是自己写的大型模块，尽量不用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python进阶之列表、元组、字典、集合</title>
    <url>/posts/a2f2547f.html</url>
    <content><![CDATA[<p>本文旨在分析python四大数据结构list、tuple、dict、set的原理和操作时间复杂度，以便在实际场景中按照需求做出正确的选择。</p>
<a id="more"></a>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>列表(list)是python中最常用的数据结构之一，基于数组实现，区别于静态数组的是其动态增长的特性使其非常灵活，比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">a.append(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">del</span> a[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>当其初始化的内存大小不能满足append新元素的需求时，会为它进行扩容。</p>
<p>其最大的时间开销为最坏情况下的delete和insert操作，以及超过当前长度重新分配内存区域时。</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>平均情况时间复杂度</th>
<th>最坏情况时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>append</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>insert</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>index</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>delete</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>for i in list</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>len(list)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>sort</td>
<td>O(nlogn)</td>
<td>O($n^2$)</td>
</tr>
<tr>
<td>pop</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>tuple元组是不可变的list类型，不能进行增删改操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">b = (<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">c = a + b</span><br></pre></td></tr></table></figure>

<p>注意此时c引用的是新的对象</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>平均情况时间复杂度</th>
<th>最坏情况时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>count(tuple)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>len(tuple)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>for i in tuple</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h3 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h3><p>dict采用了hash表实现，key通过hash函数映射为一个int，对元素个数取模后得到对应的数组index，通过index即可访问到value，注意key是不可更改的，但value可更改。</p>
<p>dict解决hash冲突的方式：开放定址法，在发生冲突时，假设当前位置为A，那么继续探测A+1处是否冲突，直到不冲突为止，将value放进该处。</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>平均情况时间复杂度</th>
<th>最坏情况时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>delete</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>for k,v in d.items()</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>len(dict)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>set集合的实现也为hash表，与dict相似，key仍然是通过hash函数映射为一个int，对元素个数取模后得到对应的数组index，但value为空。set实现了大部分的集合运算，如求交集、并集等，但不支持通过下标访问。</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>平均情况时间复杂度</th>
<th>最坏情况时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>for i in set</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>s | t</td>
<td>O(len(s)+len(t))</td>
<td>O(len(s)+len(t))</td>
</tr>
<tr>
<td>s &amp; t</td>
<td>O(min(len(s), len(t))</td>
<td>O(len(s)*len(t))</td>
</tr>
<tr>
<td>s - t</td>
<td>O(len(s))</td>
<td>O(len(s))</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文对python四大数据结构做了初步的分析，其中部分api的性能有待补充。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之内存管理和垃圾回收机制</title>
    <url>/posts/b7597a18.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>python编码规范</title>
    <url>/posts/62c2e1c5.html</url>
    <content><![CDATA[<p>目标：写出优雅的代码</p>
<a id="more"></a>

<h4 id="PEP8编码规范"><a href="#PEP8编码规范" class="headerlink" title="PEP8编码规范"></a>PEP8编码规范</h4><h5 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h5><ol>
<li>模块命名尽量短小，使用全部小写的方式，可以使用下划线</li>
<li>函数命名使用全部小写，可以使用下划线，私有函数一般在前面加个下划线</li>
<li>常量命名使用全部大写，可以使用下划线</li>
<li>类的属性（方法和变量）使用全部小写，可以使用下划线</li>
<li>包命名尽量短小，使用全部小写，不可以使用下划线</li>
<li>避免使用混淆字母，如‘l’、‘o’等</li>
<li>类命名使用AaBb的格式驼峰法，模块内部采用_AaBb的格式</li>
<li>异常命名AaBb+Error的方式</li>
<li>全局变量尽量只在模块内有效，好像C的static，一种实现方式是_all_机制，一种是前缀一个下划线</li>
<li>类的属性鱼关键字冲突，可以后缀下划线，不要使用缩略</li>
<li>为了避免与子类属性命名冲突，可以前缀两个下划线。</li>
<li>类的方法的第一个参数必须是self，而静态方法第一个参数必须是cls</li>
</ol>
<h5 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h5><ol>
<li>缩进，四个空格，不要使用Tap</li>
<li>每行代码由长度限制，不宜太长，换行最好使用圆括号，谨慎使用反斜杠</li>
<li>类中的方法定义之间空一行；类和顶层函数定义之间空两行；函数内逻辑无关段落空一行，其他地方不空行</li>
<li>不要用分号将两条命令放在同一行，一行写一条命令</li>
<li>尽量使用is/is not取代‘==’</li>
<li>异常中不要使用裸露的except，except后跟具体的exeptions</li>
<li>异常中try的代码要少</li>
<li>使用startswith() and endswith()代替切片进行序列的前缀或后缀检查</li>
<li>使用isinstance()比较对象的类型</li>
<li>二进制数据判断使用 if boolvalue</li>
</ol>
<h5 id="文档规范"><a href="#文档规范" class="headerlink" title="文档规范"></a>文档规范</h5><ol>
<li><p>模块内容的顺序</p>
</li>
<li><p>每个import语句只导入一个模块，尽量避免一次导入多个模块，从大到小，顺序为：标准库、相关主包、特定应用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h5><ol>
<li>右括号、逗号、冒号、分号前面不要空格</li>
<li>函数和序列的左括号前不要空格，list[2]</li>
<li>操作符的左右各加一个空格，如 + ，‘*，=’两边不空格，</li>
<li>if/for/while语句中需要另起一行</li>
</ol>
<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><ol>
<li>最好是英文注释，完整的句子，首字母大写，句后有结束符</li>
<li>尽量多使用块注释，在一段代码前增加注释，#后面加一个空格，减少行注释和不必要注释</li>
<li>为所有的共有模块、函数、类、方法写docstrings，私有的不一写，但可以在def后提供一个块注释说明</li>
</ol>
<h4 id="Flake8、Pylint代码风格检查工具"><a href="#Flake8、Pylint代码风格检查工具" class="headerlink" title="Flake8、Pylint代码风格检查工具"></a>Flake8、Pylint代码风格检查工具</h4>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之字符串、列表、字典和元组</title>
    <url>/posts/2ccc3457.html</url>
    <content><![CDATA[<p>python学习第一步了解四大数据结构，他们分别为list、tuple、dict、set，初级目标是了解基本用法，进阶学习是了解底层如何实现。BUT 在这之前</p>
<a id="more"></a>
<p> 在学习四大数据结构之前先来回顾下python的基本数据类型，简单回顾下数字、字符串、布尔类型三种。</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>知其然更要知其所以然，语言的对比学习往往会让人更为深刻。python较C++更为简洁，比如声明一个变量，C++中常用的就是 数据类型 变量名，如下：<br><code>int age = 20;</code><br>python中声明的变量是直接： 变量名 = 变量值，如下：<br><code>age = 20</code></p>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>C系语言中的整数类型有很多，如int，long，long long等，使用时应明确标出。<br>python中不需要明确类型，并且没有限制长整数的数值大小，如果发生溢出，会自动转换为长整数。python中的整数类型都是int，没有long</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line">print(type(age)) <span class="comment">#查看数据类型的方法</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt; #运行结果</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>python中加了引号的都是字符串，而且多种形式的引号单独使用没有差别，只有在引号中嵌套引号才有些许差别，三引号的作用时换行和注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">'wwp'</span> <span class="comment">#单引号</span></span><br><span class="line">name = <span class="string">"wwp"</span> <span class="comment">#双引号</span></span><br><span class="line">name = <span class="string">'''wwp'''</span> <span class="comment">#三引号</span></span><br><span class="line">name = <span class="string">"What's ur name?"</span> <span class="comment">#单双引号混用</span></span><br><span class="line">name = <span class="string">'''</span></span><br><span class="line"><span class="string">第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment">#pyhton中的字符串可以相加（字符串拼接）和相乘（字符串复制）</span></span><br><span class="line">name = <span class="string">'wwp'</span>*<span class="number">3</span> <span class="comment">#字符串和数字相乘表示输出几遍，‘wwpwwpwwp’</span></span><br></pre></td></tr></table></figure>
<p>字符串中其他的常用操作如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">"ada"</span></span><br><span class="line">name.title()<span class="comment">#首字母大写显示每个单词</span></span><br><span class="line">name.upper()<span class="comment">#全部大写</span></span><br><span class="line">name.lower()<span class="comment">#全部小写</span></span><br><span class="line"><span class="comment">#\n 换行符</span></span><br><span class="line"><span class="comment">#\t制表符（大空格）</span></span><br><span class="line">name.rstrip()<span class="comment">#暂时删除变量末尾(右边right)的空格</span></span><br><span class="line">print(name)<span class="comment">#依然有空格</span></span><br><span class="line"><span class="comment">#想要永久删除空格就必须将删除后的结果存回到变量中</span></span><br><span class="line">name.lstrip()<span class="comment">#暂时删除变量前面（左边left）的空格</span></span><br><span class="line">name.strip()<span class="comment">#暂时删除变量两端的空格</span></span><br><span class="line">age = <span class="number">23</span></span><br><span class="line">str(age)<span class="comment">#把非字符串转化为字符串</span></span><br></pre></td></tr></table></figure>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>true &amp; flase</p>
<h3 id="列表LIST"><a href="#列表LIST" class="headerlink" title="列表LIST"></a>列表LIST</h3><ul>
<li>List是由一系列特定顺序排列的元素组成—–有序的（与set相对）</li>
<li>用[]表示列表，并用逗号分隔其中的元素，列表的名称常定义为复数，</li>
<li>适用于存储在程序运行期间可能变化的数据集，是可以修改的—-元素可变（与tuple相对）</li>
<li>容纳python的任何对象（与字典相对）</li>
</ul>
<h4 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h4><p>索引访问，下标从0开始。（==C++数组和vector也是索引访问，还记得数组和链表及vector的区别吗==）</p>
<p>注意：python访问最后一个列表元素，使用索引-1，返回列表的最后一个元素，常用于不知道列表长度的情况下，当然倒数第二个元素类推-2，-3，-4(不过列表为空时不能这样使用，会出错)</p>
<h4 id="修改、增加和删除元素"><a href="#修改、增加和删除元素" class="headerlink" title="修改、增加和删除元素"></a>修改、增加和删除元素</h4><p><strong>修改元素</strong>：给列表中的某元素赋新值，重新print即修改</p>
<p><strong>增加元素</strong>：</p>
<ol>
<li><p>列表末尾添加元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'Mary'</span>, <span class="string">'Tom'</span>] </span><br><span class="line">names.append(<span class="string">'Jack'</span>)</span><br><span class="line">print(names)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>python中可以使用append动态的创建列表，如先创建一个空列表，再使用一系列的append()语句添加元素，类似建立一个空的vector，然后不断的push_back()元素</p>
<p>​            2.列表中插入，insert(索引值，新元素值)可以在任何位置添加新元素</p>
<p><strong>删除元素</strong>：</p>
<ol>
<li>根据索引删除元素，元素后期不再使用</li>
</ol>
<p><code>del names[0]</code> </p>
<p>​          2.删除列表末尾的元素，并继续使用存入变量，names.pop(),类似栈的弹出</p>
<p>​          3.删除任何位置的元素，并存入变量，names.pop(索引)</p>
<p>​          4.根据值删除元素，names.remove(‘Mary’),remove只是删除第一个出现的值，如果某元素重复出现多次，应该循环判断是否删除完毕</p>
<h4 id="组织列表"><a href="#组织列表" class="headerlink" title="组织列表"></a>组织列表</h4><ol>
<li>永久性排序，不可恢复，names.sort(),/names.sort(reverse=True)逆序</li>
<li>临时显示特定排序，不影响列表的原始顺序，print(sorted(names))</li>
<li>反转列表的排列顺序，names.reverse(),逆序，如果需要恢复，再次reverse</li>
<li>求列表长度len(names)</li>
</ol>
<h4 id="数值列表"><a href="#数值列表" class="headerlink" title="数值列表"></a>数值列表</h4><ol>
<li>range(start，end)函数，输出从start开始的数字，到end结束（不包括end）</li>
<li>list(range(start, end))函数，把range的结束直接转换为列表</li>
<li>range(start, end, step)可以指定步长增加直到end</li>
</ol>
<h4 id="切片-部分元素"><a href="#切片-部分元素" class="headerlink" title="切片(部分元素)"></a>切片(部分元素)</h4><ol>
<li>指定开始和结尾索引，在结尾索引前停止(不包括结尾处)</li>
<li>没有指定开始索引代表从列表头开始，没有制定结束索引，代表从列表尾结束</li>
<li>复制列表，同时省略起始索引</li>
</ol>
<h3 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h3><p>不可修改的不可变的列表，使用圆括号（）表示，同样使用索引访问元组，即可查询不可修改的列表</p>
<h3 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h3><ul>
<li>花括号表示{key:value},元素是key与value的对应关系组，通过key访问value</li>
<li>key键不能重复，但是值可以重复</li>
<li>字典中的key键是不可变的，无法修改的，但是值value是可变的可修改的，可以是任何对象</li>
<li>无序存储，python对key进行哈希数字运算，根据计算结果决定value的地址，所以是无序，所以key需要是能被哈希的，即必须是不可变类型，数字字符串元组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 还记得C++的map吗</span></span><br><span class="line"><span class="comment"># 添加单个键值对</span></span><br><span class="line">students = &#123;&#125;</span><br><span class="line">students[<span class="string">'Mary'</span>] = <span class="number">5</span> <span class="comment">#增加一个键值对Mary-5</span></span><br><span class="line"><span class="comment"># 添加多个键值对</span></span><br><span class="line"><span class="comment"># 删除元素</span></span><br><span class="line"><span class="keyword">del</span> students[<span class="string">'Mary'</span>]<span class="comment">#删除时要指定字典名和要删除的键</span></span><br><span class="line"><span class="comment"># 遍历字典</span></span><br><span class="line"><span class="keyword">for</span> key，value <span class="keyword">in</span> students.items()</span><br><span class="line"><span class="comment"># 遍历所有的键</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> students.keys():<span class="comment">#方法key（）可以省略，但是加上更好，key返回一个包含字典中所有键的列表</span></span><br><span class="line"><span class="comment"># 遍历所有的值</span></span><br><span class="line"><span class="keyword">for</span> age <span class="keyword">in</span> students.values():<span class="comment">#方法values（）返回一个包含字典中所有值的列表</span></span><br></pre></td></tr></table></figure>

<h3 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h3><ul>
<li>花括号表示{}，无序的，不重复的，任意的元素，是不是跟C++的set很像</li>
<li>一般用set去掉重复元素</li>
<li>集合不能切片也不能使用索引，毕竟是无序的</li>
</ul>
<p>总结：每个数据结构应该处理哪些数据，应用在哪些场景中</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>W老师语录</title>
    <url>/posts/4c3f0d3b.html</url>
    <content><![CDATA[<p>研究生进入我们实验室，并受到了W老师学习上和思想上的多次教导，受益匪浅。<br>特此记录，以勉励自己未来继续努力。<br>W老师是我见过最好的老师，最棒的老师，真正的科研思维。</p>
<a id="more"></a>

<ol>
<li>爱因斯坦：“大学教育的价值不在于记住很多事实，而是训练大脑会思考”</li>
<li>冯·卡门：“科学家研究已有的世界，工程师创造未来的世界”。<br>科学家与工程师的区别最先在于科学与工程两个概念的区别：科学在于探索客观世界中存在的客观规律，所以科学强调分析，强调结论的唯一性；工程是人们综合应用科学理论和技术手段去改造客观世界的实践活动，所以工程强调综合，强调方案比较论证。这也是科学与工程的主要不同之处。</li>
<li>“指南”通常也意味着需求。</li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>“随笔”</tag>
      </tags>
  </entry>
  <entry>
    <title>写在嘉陵江畔</title>
    <url>/posts/2bc0ac71.html</url>
    <content><![CDATA[<p>本该秋雨绵绵的时节，不过重庆向来与秋无缘，昨天嘉陵江畔烧烤我们还大汗淋漓，今早起床感觉一秒入冬。这种天气本该不喜，不过想想这该是我最后享受重庆的湿冷，享受重庆的风土人情，果断出门，冬风细雨也难以阻挡这最后的步伐</p>
<a id="more"></a>

<!-- ![IMG_4676](/images/IMG_4676.jpg)-->
<img src="/posts/2bc0ac71/IMG_4676.jpg" class title="IMG_4676">
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>两小时一起快速搭建个人博客</title>
    <url>/posts/8f145c5e.html</url>
    <content><![CDATA[<p>两个小时的时间我一般用来鉴赏影片，不过搭一个博客刚好也OK。<br>搭建一个自己的博客需三部曲：<strong><em>下载安装包，部署环境，美化博客页面</em></strong></p>
<a id="more"></a>

<h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><p>本文用的博客是使用Hexo + Github，需要安装以下内容：</p>
<ol>
<li><p>安装Node.js，安装地址：<a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">Node.js下载链接</a></p>
</li>
<li><p>安装Git，安装地址：<a href="http://git-scm.com/download/" target="_blank" rel="noopener">Git下载地址</a><br>对于以上两个安装Mac建议从Homebrew安装node和git，那需要先安装Homebrew。<br>a. 首先打开官网 <a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a> ，你会在官网主页看到如下所示的内容:<br><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</code><br>b. 打开终端，输入上述命令,  即：<br><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</code><br>c. 点击回车<br>d. 输入电脑密码，等待安装<br>e. 显示Installation successful!表示安装成功<br>f. 开始使用命令行安装node和git，<code>brew install node</code> 和<code>brew install git</code></p>
</li>
<li><p>安装Hexo，使用npm安装，建议用root权限，不然会有权限问题。<br>a. 输入命令<code>sudo npm install -g hexo-cli</code>开始安装<br>b. 初始化blog文件夹<code>hexo init blog</code>,这里会从npm源安装，很容易卡住，建议使用淘宝的npm镜像，安装速度很快，依次输入以下命令<code>npm config set registry https://registry.npm.taobao.org</code>和<code>npm info express</code>,第二个命令是看看npm是否装好，此时再初始化blog文件夹（ATTENTION:如果你刚刚init过程失败，你要把生成的blog删除，再执行<code>hexo init blog</code>）<br>c. <code>cd blog</code><br>d. <code>npm install</code><br>e. <code>hexo g</code>这个命令是生成网页的静态文件，会生成一个public的文件<br>f. <code>hexo s</code>这个是启动本地服务，这样你就可以在 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 中预览你的博客</p>
<p>至此已经完成了搭建博客的三分之一了。</p>
</li>
</ol>
<h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><ol>
<li>git的创建，首先你需要一个github的账号，默认已有，然后在你的git主页创建一个新的仓库，点击New repository。填入创建仓库的名称，必须是Yournsername.github.io这很关键，也就是你后面博客的网址。最后直接点击最下面的创建按钮，其他什么都不要动。</li>
<li>hexo关联到Github，打开blog文件夹，里面有一个名为_config.yml的文件，用文本编辑器打开并编辑他，在文档最后deploy，输入以下信息<br><code>deploy</code>:<br><code>type: git</code><br><code>repo: https://github.com/TristaWWP/TristaWWP.github.io.git</code><br><code>branch: master</code></li>
<li>安装扩展<code>npm install hexo-deployer-git --save</code></li>
<li>完成部署<code>hexo d</code>，期间会输入你的用户名和密码。</li>
</ol>
<h2 id="美化博客页面"><a href="#美化博客页面" class="headerlink" title="美化博客页面"></a>美化博客页面</h2><p>俗语说：人靠衣装，确实，我就很喜欢好看的衣服，同样博客也要靠主题的装扮，虽然博客中自带了主题，但是越好看的主题越能展现一个人的个性。你可以进入<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网</a>选择自己喜欢的主题，我一开始选的next主题，后来感觉这个貌似超多人用，于是在官网选购一番，耗时半小时之久都没选到喜欢的，还是用回了next，在这里我太佩服前端和UI的小伙伴了。</p>
<ol>
<li>进入主题文件夹 <code>cd blog</code></li>
<li>下载主题 <code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code></li>
<li>修改主题的配置文件_config.yml中的theme属性，设置为next</li>
<li>然后进行一系列的美化页面效果，请参看这位老哥的文章，十分全面，<a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">Next主题的个性化教程</a></li>
<li>然后就可以创建一篇新的博客<code>hexo new &quot;博客标题&quot;</code>，会产生一个md文件，用文本编辑器打开，并且在里面任意发挥开始你的第一篇博客吧。</li>
<li>简单两行完成发布文章，以后每次这样进行就可以更新博客了<code>hexo g</code>  <code>hexo d</code></li>
</ol>
<p>对于网速实在很差的实验室来说，应该刚好两个小时搞定，不过写这篇博文又用了两个小时。。。</p>
]]></content>
      <categories>
        <category>软件类使用</category>
      </categories>
      <tags>
        <tag>软件类使用</tag>
      </tags>
  </entry>
</search>
