<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python之文件和异常</title>
    <url>/posts/f8bc5ee8.html</url>
    <content><![CDATA[<h4 id="从文件读取数据"><a href="#从文件读取数据" class="headerlink" title="从文件读取数据"></a>从文件读取数据</h4><h5 id="读取整个文件"><a href="#读取整个文件" class="headerlink" title="读取整个文件"></a>读取整个文件</h5><a id="more"></a>

<p>首先需要打开文件，使用函数open()打开文件，参数为要打开文件的名称(或者相对文件路径或绝对文件路径），pyhton在当前执行的文件所在的目录中查找指定的文件，因此要打开的文件应该放在当前文件的目录里。函数open返回一个表示文件的对象，将这个对象存在file_object中。（还记得C++打开文件的文件指针吗）</p>
<p>with关键字在不再需要访问文件后将其关闭，这比直接使用close函数要好，因为1 如果程序出现bug，导致close语句未执行，文件就不会关闭。2 过早的调用了close，后面再使用文件时就会出现错误（无法访问），所以不能很好的确定关闭文件的正确时机，使用with可以让python自己判断自动再合适的时机关闭</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"要打开文件的名称"</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">     contents = file_object.read() <span class="comment">#拥有文件对象后，调用read方法</span></span><br><span class="line">     print(contents)    <span class="comment">#print(contents.rstrip())删除空行</span></span><br></pre></td></tr></table></figure>

<p>打印结果会多一个空行，因为read函数到达文件末尾时返回一个空字符串，将这个空字符串显示出来就是一个空行，要删除多余的空行，使用rstrip()<br><strong>ATTENTION：在使用文件路径时，OS和linux采用/斜杠，windows采用\反斜杠</strong></p>
<h5 id="逐行读取"><a href="#逐行读取" class="headerlink" title="逐行读取"></a>逐行读取</h5><p>使用for循环遍历文件中的每一行，同样直接打印的话，每一行都有一个换行符，使用rstrip删除空行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"要打开文件的名称"</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">     <span class="keyword">for</span> line <span class="keyword">in</span> file_object：</span><br><span class="line">     print(line)    <span class="comment">#print(line.rstrip())删除空行</span></span><br></pre></td></tr></table></figure>

<h5 id="创建一个包含文件各行内容的列表"><a href="#创建一个包含文件各行内容的列表" class="headerlink" title="创建一个包含文件各行内容的列表"></a>创建一个包含文件各行内容的列表</h5><p>使用with关键字时，open返回的文件对象只在with代码中使用，如果想在with代码块外访问文件内容，可以在with代码块内将文件的各行存储在一个列表中，这样就可以在代码块外使用这个列表了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"要打开文件的名称"</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines() <span class="comment">#从文件中读取每一行，并把它存储在一个列表中</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    print(line.rstrip())</span><br></pre></td></tr></table></figure>


<h5 id="使用文件内容"><a href="#使用文件内容" class="headerlink" title="使用文件内容"></a>使用文件内容</h5><p>使用文本文件时，pyhton将其中的所有文本解读成字符串，如果读取的是数字，需要作为数值使用，就必须使用int函数将其转换为整数或者float将其转化为浮点数</p>
<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><h5 id="写入空文件"><a href="#写入空文件" class="headerlink" title="写入空文件"></a>写入空文件</h5><p>调用open函数提供两个实参，第一个是要打开文件的名称，第二个是以写入模式(‘w’)打开文件，另外还有读取模式(‘r’)附加模式(‘a’)以及这几种的混合模式，，省略第二个实参默认只读模式打开文件，如果写入文件不存在，open函数会自动创建。以写入模式打开文件需要注意，如果指定文件已经存在，python将在返回文件对象前清空该文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">     file_object.write(<span class="string">"I love programming"</span>)</span><br></pre></td></tr></table></figure>
<p>注意：python只能将字符串写入文本文件，要将数值数据存储到文本文件中，必须使用函数str()将其转化为字符串格式</p>
<h5 id="写入多行"><a href="#写入多行" class="headerlink" title="写入多行"></a>写入多行</h5><p>函数write()不会在写入的文本末尾添加换行符，因此写入多行时会挤到一起，因此在write语句中增加换行符，保证文件中的内容能够显示在不同行</p>
<h5 id="附加到文件"><a href="#附加到文件" class="headerlink" title="附加到文件"></a>附加到文件</h5><p>以附加方式打开文件，python不会在返回文件对象前清空文件，写入文件的行都将添加到文件末尾，是给文件添加内容，而不是覆盖原有的内容，如果文件不存在将创建一个空文件</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>每当发生python错误时，都会创建一个异常对象，如果不对异常进行处理，程序就会停止，并显示一个traceback。异常是使用try-except代码块处理的。</p>
<h5 id="处理ZeroDivisionError异常"><a href="#处理ZeroDivisionError异常" class="headerlink" title="处理ZeroDivisionError异常"></a>处理ZeroDivisionError异常</h5><p>对除0异常进行处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="number">5</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">"U cannt divide by zero"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="处理FileNotFoundError异常"><a href="#处理FileNotFoundError异常" class="headerlink" title="处理FileNotFoundError异常"></a>处理FileNotFoundError异常</h5><p>使用文件时，找不到文件就会出现FileNotFoundError异常，这是python找不到要打开的文件时创建的异常，这个错误时open函数导致的，要处理这个错误，必须把try放到包含open函数的代码行之前。</p>
<h5 id="pass语句什么都不做"><a href="#pass语句什么都不做" class="headerlink" title="pass语句什么都不做"></a>pass语句什么都不做</h5><p>正确的使用异常很多时候也靠项目经验，但是正确处理异常现象非常重要，比如上面打开文件的错误异常，在实际项目中严谨的代码是要处理这个异常的。尽量编写优雅的代码，经过详尽测试的不容易出现内部错误的代码，丰富的项目经验可以让我们判断出程序在哪里会出现异常以及出现错误时应该向用户提供哪些相关信息</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之迭代器、生成器</title>
    <url>/posts/6d39ca9a.html</url>
    <content><![CDATA[<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代是访问集合元素的方式之一，除了迭代器外还可以通过下标运算符来访问</p>
<a id="more"></a>
<h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>迭代器是一个可以记住遍历位置的对象，迭代器的对象从集合的第一个元素访问，直到所有元素被访问结束，迭代器只能往前不能后退。基本方法是iter()和next()<br>字符串、列表和元组都可以创建迭代器。注意：可迭代对象还有处于打开状态的files，sockets</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = iter(list)<span class="comment">#创建迭代器</span></span><br><span class="line">print(next(it))<span class="comment">#输出迭代器的下一个元素</span></span><br></pre></td></tr></table></figure>

<p>迭代器内部有一个状态，这个状态是用于记录当前迭代的位置，以便下次迭代的时候获取正确的元素</p>
<h5 id="迭代器对象可以使用常规的for语言遍历或者next函数"><a href="#迭代器对象可以使用常规的for语言遍历或者next函数" class="headerlink" title="迭代器对象可以使用常规的for语言遍历或者next函数"></a>迭代器对象可以使用常规的for语言遍历或者next函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = iter(list)<span class="comment">#创建迭代器</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    print(x)</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">import</span> sys <span class="comment">#引入sys模块</span></span><br><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = iter(list)<span class="comment">#创建迭代器</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(next(it))</span><br><span class="line"><span class="keyword">except</span> StopIteration:<span class="comment">#该异常用于标识迭代的完成，防止出现无限循环情况</span></span><br><span class="line"> sys.exit()</span><br></pre></td></tr></table></figure>
<h5 id="把类作为迭代器使用"><a href="#把类作为迭代器使用" class="headerlink" title="把类作为迭代器使用"></a>把类作为迭代器使用</h5><p>把类作为迭代器使用需要实现两个方法<em>iter</em>()和<em>next</em>()，看到这两个方法的形式，你还记得前面学过的<em>init</em>()吗（用于初始化）<br><em>iter</em>()函数返回一个特殊的迭代器对象，这个对象实现了<em>next</em>()方法并通过StopIteration异常标识迭代的完成。<br><em>next</em>()方法会返回下一个迭代器对象,如果容器中没有更多的元素了，则抛出异常。<br>创建一个返回数字的迭代器，初始值为1，逐步增加1，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Class Getnumber:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_iter_</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_next_</span><span class="params">(self)</span>:</span></span><br><span class="line">        x = self.a</span><br><span class="line">        self.a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">getnumber = Getnumber()</span><br><span class="line">myiter = iter(getnumber)</span><br><span class="line"></span><br><span class="line">print(next(myiter))  </span><br><span class="line">print(next(myiter))</span><br></pre></td></tr></table></figure>

<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><p>使用了yield的函数称为生成器，生成器是一个返回迭代器的函数（一个特殊的迭代器），只能用于迭代操作，返回数据时会使用yield语句，不需要上面两个方法了。<br>在调用生成器运行的过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值，并在下一次执行next方法时从当前位置继续运行。<br>调用一个生成器函数，返回是一个迭代器对象（不需要return了）。</p>
<h5 id="对比是否用yield实例"><a href="#对比是否用yield实例" class="headerlink" title="对比是否用yield实例"></a>对比是否用yield实例</h5><p>使用yield斐波那契</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n, w = <span class="number">0</span>)</span>:</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span>(counter &gt; n):</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">       print(<span class="string">'%d, %d'</span> %(a, b))</span><br><span class="line">       counter += <span class="number">1</span></span><br><span class="line">   f = fibonacci(<span class="number">10</span>,<span class="number">0</span>) <span class="comment"># f是一个由生成器返回的迭代器         </span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">    print(next(f), end = <span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">except</span> :</span><br><span class="line">    sys.exit()</span><br></pre></td></tr></table></figure>

<p>不使用yield斐波那契，（注释掉yield）函数只是简单执行，没有返回迭代器f</p>
<h5 id="什么情况需要使用yield"><a href="#什么情况需要使用yield" class="headerlink" title="什么情况需要使用yield"></a>什么情况需要使用yield</h5><p>划重点减少大内存的使用，举例：当我们调用函数返回一个很大的list时，一般情况是得到一个很大的list之后再去使用，这样就会非常占用内存，但是实际上我们使用的是list的遍历（list的迭代器），不需要得到完整的list，所以我们可以让这个函数每次只返回一个迭代器的一个计算结果，这个时候yield就很有用。<br>使用生成器不仅可以节省内存和CPU，还可以用更少的代码实现相似的功能</p>
<p>题外话：还记得C++如何优化斐波那契求解，传统的C++求解斐波那契会递归很多次，产生递归栈，最后因为栈溢出崩溃，优化递归部分以解决重复计算问题，优化算法，从下往上计算，根据f(0),f(1)得到f(2),再有f(1)和f(2)得到f(3)</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之装饰器和闭包</title>
    <url>/posts/33412124.html</url>
    <content><![CDATA[<p>装饰器与闭包的学习</p>
<a id="more"></a>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="初识装饰器"><a href="#初识装饰器" class="headerlink" title="初识装饰器"></a>初识装饰器</h3><p>装饰器(decorator)实际上是一个函数，用来改变其他函数的功能，如果我们有一个函数，功能为打印一句话</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">"hello, I am f1."</span>)</span><br></pre></td></tr></table></figure>

<p>现在我们需要改变打印的内容，但是不能修改此函数中的打印语句，那么我们可以添加一个函数，修改f1这个引用指向的对象为新的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">			print(<span class="string">"hello, I am NOT f1."</span>)</span><br><span class="line">	<span class="keyword">return</span> inner</span><br><span class="line">f1 = decorator(f1)</span><br></pre></td></tr></table></figure>

<p>运行f1，得到的结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line">hello, I am NOT f1.</span><br></pre></td></tr></table></figure>

<p>可以看到，我们成功地改变了原函数的打印语句，上面的decorator函数即为python中的<strong>装饰器</strong>，我们可以使用语法糖@将上面的python代码简化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">"hello, I am f1."</span>)</span><br></pre></td></tr></table></figure>



<h3 id="Python何时执行装饰器"><a href="#Python何时执行装饰器" class="headerlink" title="Python何时执行装饰器"></a>Python何时执行装饰器</h3><p>装饰器在模块导入时即执行，而不是显示调用被装饰的函数时才执行，下面我们来看一个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">  	print(<span class="string">'running register(%s)'</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">		<span class="keyword">return</span> func</span><br><span class="line">  </span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'running f1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'running f2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  	f1()</span><br><span class="line">    f2()</span><br></pre></td></tr></table></figure>

<p>如果上面的py文件当做脚本运行，那么可以得到结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">running register(&lt;function f1 at <span class="number">0x100f962a8</span>&gt;)</span><br><span class="line">running register(&lt;function f2 at <span class="number">0x100f961b8</span>&gt;)</span><br><span class="line">running f1</span><br><span class="line">running f2</span><br></pre></td></tr></table></figure>

<p>如果是当做模块导入，那么结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">running register(&lt;function f1 at <span class="number">0x100f962a8</span>&gt;)</span><br><span class="line">running register(&lt;function f2 at <span class="number">0x100f961b8</span>&gt;)</span><br></pre></td></tr></table></figure>

<p>这也证实了装饰器在模块导入时运行</p>
<h3 id="装饰器的功能"><a href="#装饰器的功能" class="headerlink" title="装饰器的功能"></a>装饰器的功能</h3><p>从上面的例子可以看到，我们可以将工程中的register函数定义为装饰器，其他功能函数在使用之前必须要经过装饰器注册后才能使用，在需要临时取消某些函数功能时，只需要去掉语法糖”@”即可，功能强大且非常灵活、</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">  	print(<span class="string">'running register(%s)'</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">		<span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用f1</span></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'running f1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用f2</span></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'running f2'</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 禁用f3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'running f3'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">manager</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">for</span> func <span class="keyword">in</span> registry:</span><br><span class="line">    	<span class="string">"""do something"""</span></span><br><span class="line">    	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，f1和f2两个功能函数启用，f3被禁用，manager函数实现对所有启用的函数进行操作。</p>
<h3 id="Python变量的作用域"><a href="#Python变量的作用域" class="headerlink" title="Python变量的作用域"></a>Python变量的作用域</h3><p>python变量遵循”LEGB”原则，L(local)，E(enclosing)，G(global)，B(built-in)，即解释器在寻找变量时，会现在函数内部(local)里寻找，如果找不到，去外层函数(enclosing)中寻找，最后去全局变量(global)和内建(built-in)中寻找，下面看一个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a)</span>:</span></span><br><span class="line">  	print(a)</span><br><span class="line">    print(b)</span><br><span class="line">f1(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>显然，最终的输出结果为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这是因为解释器把b当做了全局变量打印，现在我们稍作修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a)</span>:</span></span><br><span class="line">  	print(a)</span><br><span class="line">  	b = <span class="number">3</span></span><br><span class="line">    print(b)</span><br><span class="line">f1(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>现在的输出结果为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>现在的变量b是局部(local)变量，解释器优先在local里寻找，而不是global，我们再加修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a)</span>:</span></span><br><span class="line">  	print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    b = <span class="number">3</span></span><br><span class="line">f1(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">UnboundLocalError: local variable <span class="string">'b'</span> referenced before assignment</span><br></pre></td></tr></table></figure>

<p>这是因为此时的b在编译阶段被确认为局部变量，但是我们未经赋值就进行使用，所以会报错！</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>Python从入门到实践习题参考</title>
    <url>/posts/5c354b05.html</url>
    <content><![CDATA[<p>好记性不如烂笔头，虽然习题简单，还是需要操作的<br>如下：<a href="https://github.com/TristaWWP/Python-programming-reference-/tree/master" target="_blank" rel="noopener">Python从入门到实践习题参考</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python入门之条件、循环、函数、模块</title>
    <url>/posts/1598b31a.html</url>
    <content><![CDATA[<p>python的简单了解，关于条件、循环、函数和模块，本文均为基础知识</p>
<a id="more"></a>

<h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><p>C++:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件):</span><br><span class="line">    执行代码</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(条件):</span><br><span class="line">    执行代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    执行代码</span><br></pre></td></tr></table></figure>

<p>python：不需要括号，并且第二个为elif</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件：</span><br><span class="line">    执行代码</span><br><span class="line"><span class="keyword">elif</span> 条件：</span><br><span class="line">    执行代码</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    执行代码</span><br></pre></td></tr></table></figure>

<p>C++用{}表示一个程序块，python代码结构由：和 缩进表示同为一个程序块<br>python中检查多个条件是否为true用and连接（类比C++中&amp;&amp;）<br>检查是否有一个相等or（类比||）<br>检查是否包含在列表中使用in，不包含使用not in</p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>C++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)<span class="comment">//用n控制循环</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range://采用序列的方式控制循环</span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><p>关键字def定义一个函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""显示简单的问候语"""</span><span class="comment">#该行为docstring，文档字符串的注释，描述函数做什么的</span></span><br><span class="line">    print(<span class="string">"hello"</span>)     <span class="comment">#该行为函数体</span></span><br></pre></td></tr></table></figure>

<h5 id="传递实参"><a href="#传递实参" class="headerlink" title="传递实参"></a>传递实参</h5><ul>
<li><p>位置实参：实参和形参的传递顺序相同，就是类似普通的参数传递</p>
</li>
<li><p>关键字实参：在实参中将名称和值关联起来，这样在传递的过程不会混淆,无序考虑函数调用中的实参顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span><span class="params">(animal_type, pet_name)</span>:</span></span><br><span class="line">    XXXXXXX</span><br><span class="line">describe_pet(animal_type=<span class="string">'hamster'</span>, pet_name=<span class="string">'harry'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认值，给形参指定默认值，使用默认值时，在形参列表中必须先列出没有默认值的形参，再列出有默认值的实参。这让Python依然能够正确地解读位置实参</p>
</li>
</ul>
<h5 id="禁止函数修改列表"><a href="#禁止函数修改列表" class="headerlink" title="禁止函数修改列表"></a>禁止函数修改列表</h5><p>方法：向函数传递列表的副本而不是原件，这样函数的任何修改都只是影响副本，不影响原件。切片表示法[:]是创建列表的副本。<br><code>function_name(list_name[:]) #传递列表的副本</code></p>
<p>BUT一般还是要传递原始列表给函数，因为原始列表可以避免花费时间和内存创建副本，从而提高效率，处理大型列表更要如此。</p>
<h5 id="传递任意数量的实参"><a href="#传递任意数量的实参" class="headerlink" title="传递任意数量的实参"></a>传递任意数量的实参</h5><p>形参名 * XXX中的 * 是创建一个名为XXX的空元组，并把收到的所有值都封装到这个元组中。注意：python将实参封装到一个元组中，即便函数只收到一个值也是如此。** XXX中的** 是创建一个空字典，这样就可以使用关键字形参了（键值对形式）</p>
<h5 id="函数接受任意数量的实参和位置实参混合使用"><a href="#函数接受任意数量的实参和位置实参混合使用" class="headerlink" title="函数接受任意数量的实参和位置实参混合使用"></a>函数接受任意数量的实参和位置实参混合使用</h5><p>要把接受任意数量的实参的形参放在最后，函数接收参数时，先匹配位置实参和关键字实参，最后再将余下实参都放到最后一个形参中。</p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>模块是扩展名为.py的文件，包含要导入到程序的代码。一般将函数存储在模块的独立文件中，再将模块导入到主程序中</p>
<h5 id="直接导入模块"><a href="#直接导入模块" class="headerlink" title="直接导入模块"></a>直接导入模块</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module_name</span><br><span class="line">mudule_name.func   <span class="comment">#调用函数方法</span></span><br></pre></td></tr></table></figure>

<h5 id="导入特定函数"><a href="#导入特定函数" class="headerlink" title="导入特定函数"></a>导入特定函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> func_1,func_2.......</span><br><span class="line">func_1() <span class="comment">#直接调用函数</span></span><br></pre></td></tr></table></figure>

<h5 id="使用as给函数起别名，防止命名冲突或函数名太长，也可用as给模块指定别名，方法同前"><a href="#使用as给函数起别名，防止命名冲突或函数名太长，也可用as给模块指定别名，方法同前" class="headerlink" title="使用as给函数起别名，防止命名冲突或函数名太长，也可用as给模块指定别名，方法同前"></a>使用as给函数起别名，防止命名冲突或函数名太长，也可用as给模块指定别名，方法同前</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> func <span class="keyword">as</span> ff</span><br><span class="line">ff() <span class="comment">#直接使用函数的别名</span></span><br></pre></td></tr></table></figure>

<h5 id="使用-带入模块中的所有函数-不过如果不是自己写的大型模块，尽量不用"><a href="#使用-带入模块中的所有函数-不过如果不是自己写的大型模块，尽量不用" class="headerlink" title="使用*带入模块中的所有函数,不过如果不是自己写的大型模块，尽量不用"></a>使用*带入模块中的所有函数,不过如果不是自己写的大型模块，尽量不用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python进阶之列表、元组、字典、集合</title>
    <url>/posts/a2f2547f.html</url>
    <content><![CDATA[<p>本文旨在分析python四大数据结构list、tuple、dict、set的原理和操作时间复杂度，以便在实际场景中按照需求做出正确的选择。</p>
<a id="more"></a>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>列表(list)是python中最常用的数据结构之一，基于数组实现，区别于静态数组的是其动态增长的特性使其非常灵活，比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">a.append(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">del</span> a[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>当其初始化的内存大小不能满足append新元素的需求时，会为它进行扩容。</p>
<p>其最大的时间开销为最坏情况下的delete和insert操作，以及超过当前长度重新分配内存区域时。</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>平均情况时间复杂度</th>
<th>最坏情况时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>append</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>insert</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>index</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>delete</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>for i in list</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>len(list)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>sort</td>
<td>O(nlogn)</td>
<td>O($n^2$)</td>
</tr>
<tr>
<td>pop</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>tuple元组是不可变的list类型，不能进行增删改操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">b = (<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">c = a + b</span><br></pre></td></tr></table></figure>

<p>注意此时c引用的是新的对象</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>平均情况时间复杂度</th>
<th>最坏情况时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>count(tuple)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>len(tuple)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>for i in tuple</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h3 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h3><p>dict采用了hash表实现，key通过hash函数映射为一个int，对元素个数取模后得到对应的数组index，通过index即可访问到value，注意key是不可更改的，但value可更改。</p>
<p>dict解决hash冲突的方式：开放定址法，在发生冲突时，假设当前位置为A，那么继续探测A+1处是否冲突，直到不冲突为止，将value放进该处。</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>平均情况时间复杂度</th>
<th>最坏情况时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>delete</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>for k,v in d.items()</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>len(dict)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>set集合的实现也为hash表，与dict相似，key仍然是通过hash函数映射为一个int，对元素个数取模后得到对应的数组index，但value为空。set实现了大部分的集合运算，如求交集、并集等，但不支持通过下标访问。</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>平均情况时间复杂度</th>
<th>最坏情况时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>for i in set</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>s | t</td>
<td>O(len(s)+len(t))</td>
<td>O(len(s)+len(t))</td>
</tr>
<tr>
<td>s &amp; t</td>
<td>O(min(len(s), len(t))</td>
<td>O(len(s)*len(t))</td>
</tr>
<tr>
<td>s - t</td>
<td>O(len(s))</td>
<td>O(len(s))</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文对python四大数据结构做了初步的分析，其中部分api的性能有待补充。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之内存管理和垃圾回收机制</title>
    <url>/posts/b7597a18.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>python编码规范</title>
    <url>/posts/62c2e1c5.html</url>
    <content><![CDATA[<p>目标：写出优雅的代码</p>
<a id="more"></a>

<h4 id="PEP8编码规范"><a href="#PEP8编码规范" class="headerlink" title="PEP8编码规范"></a>PEP8编码规范</h4><h5 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h5><ol>
<li>模块命名尽量短小，使用全部小写的方式，可以使用下划线</li>
<li>函数命名使用全部小写，可以使用下划线，私有函数一般在前面加个下划线</li>
<li>常量命名使用全部大写，可以使用下划线</li>
<li>类的属性（方法和变量）使用全部小写，可以使用下划线</li>
<li>包命名尽量短小，使用全部小写，不可以使用下划线</li>
<li>避免使用混淆字母，如‘l’、‘o’等</li>
<li>类命名使用AaBb的格式驼峰法，模块内部采用_AaBb的格式</li>
<li>异常命名AaBb+Error的方式</li>
<li>全局变量尽量只在模块内有效，好像C的static，一种实现方式是_all_机制，一种是前缀一个下划线</li>
<li>类的属性鱼关键字冲突，可以后缀下划线，不要使用缩略</li>
<li>为了避免与子类属性命名冲突，可以前缀两个下划线。</li>
<li>类的方法的第一个参数必须是self，而静态方法第一个参数必须是cls</li>
</ol>
<h5 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h5><ol>
<li>缩进，四个空格，不要使用Tap</li>
<li>每行代码由长度限制，不宜太长，换行最好使用圆括号，谨慎使用反斜杠</li>
<li>类中的方法定义之间空一行；类和顶层函数定义之间空两行；函数内逻辑无关段落空一行，其他地方不空行</li>
<li>不要用分号将两条命令放在同一行，一行写一条命令</li>
<li>尽量使用is/is not取代‘==’</li>
<li>异常中不要使用裸露的except，except后跟具体的exeptions</li>
<li>异常中try的代码要少</li>
<li>使用startswith() and endswith()代替切片进行序列的前缀或后缀检查</li>
<li>使用isinstance()比较对象的类型</li>
<li>二进制数据判断使用 if boolvalue</li>
</ol>
<h5 id="文档规范"><a href="#文档规范" class="headerlink" title="文档规范"></a>文档规范</h5><ol>
<li><p>模块内容的顺序</p>
</li>
<li><p>每个import语句只导入一个模块，尽量避免一次导入多个模块，从大到小，顺序为：标准库、相关主包、特定应用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h5><ol>
<li>右括号、逗号、冒号、分号前面不要空格</li>
<li>函数和序列的左括号前不要空格，list[2]</li>
<li>操作符的左右各加一个空格，如 + ，‘*，=’两边不空格，</li>
<li>if/for/while语句中需要另起一行</li>
</ol>
<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><ol>
<li>最好是英文注释，完整的句子，首字母大写，句后有结束符</li>
<li>尽量多使用块注释，在一段代码前增加注释，#后面加一个空格，减少行注释和不必要注释</li>
<li>为所有的共有模块、函数、类、方法写docstrings，私有的不一写，但可以在def后提供一个块注释说明</li>
</ol>
<h4 id="Flake8、Pylint代码风格检查工具"><a href="#Flake8、Pylint代码风格检查工具" class="headerlink" title="Flake8、Pylint代码风格检查工具"></a>Flake8、Pylint代码风格检查工具</h4>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之字符串、列表、字典和元组</title>
    <url>/posts/2ccc3457.html</url>
    <content><![CDATA[<p>python学习第一步了解四大数据结构，他们分别为list、tuple、dict、set，初级目标是了解基本用法，进阶学习是了解底层如何实现。BUT 在这之前</p>
<a id="more"></a>
<p> 在学习四大数据结构之前先来回顾下python的基本数据类型，简单回顾下数字、字符串、布尔类型三种。</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>知其然更要知其所以然，语言的对比学习往往会让人更为深刻。python较C++更为简洁，比如声明一个变量，C++中常用的就是 数据类型 变量名，如下：<br><code>int age = 20;</code><br>python中声明的变量是直接： 变量名 = 变量值，如下：<br><code>age = 20</code></p>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>C系语言中的整数类型有很多，如int，long，long long等，使用时应明确标出。<br>python中不需要明确类型，并且没有限制长整数的数值大小，如果发生溢出，会自动转换为长整数。python中的整数类型都是int，没有long</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line">print(type(age)) <span class="comment">#查看数据类型的方法</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt; #运行结果</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>python中加了引号的都是字符串，而且多种形式的引号单独使用没有差别，只有在引号中嵌套引号才有些许差别，三引号的作用时换行和注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">'wwp'</span> <span class="comment">#单引号</span></span><br><span class="line">name = <span class="string">"wwp"</span> <span class="comment">#双引号</span></span><br><span class="line">name = <span class="string">'''wwp'''</span> <span class="comment">#三引号</span></span><br><span class="line">name = <span class="string">"What's ur name?"</span> <span class="comment">#单双引号混用</span></span><br><span class="line">name = <span class="string">'''</span></span><br><span class="line"><span class="string">第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment">#pyhton中的字符串可以相加（字符串拼接）和相乘（字符串复制）</span></span><br><span class="line">name = <span class="string">'wwp'</span>*<span class="number">3</span> <span class="comment">#字符串和数字相乘表示输出几遍，‘wwpwwpwwp’</span></span><br></pre></td></tr></table></figure>
<p>字符串中其他的常用操作如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">"ada"</span></span><br><span class="line">name.title()<span class="comment">#首字母大写显示每个单词</span></span><br><span class="line">name.upper()<span class="comment">#全部大写</span></span><br><span class="line">name.lower()<span class="comment">#全部小写</span></span><br><span class="line"><span class="comment">#\n 换行符</span></span><br><span class="line"><span class="comment">#\t制表符（大空格）</span></span><br><span class="line">name.rstrip()<span class="comment">#暂时删除变量末尾(右边right)的空格</span></span><br><span class="line">print(name)<span class="comment">#依然有空格</span></span><br><span class="line"><span class="comment">#想要永久删除空格就必须将删除后的结果存回到变量中</span></span><br><span class="line">name.lstrip()<span class="comment">#暂时删除变量前面（左边left）的空格</span></span><br><span class="line">name.strip()<span class="comment">#暂时删除变量两端的空格</span></span><br><span class="line">age = <span class="number">23</span></span><br><span class="line">str(age)<span class="comment">#把非字符串转化为字符串</span></span><br></pre></td></tr></table></figure>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>true &amp; flase</p>
<h3 id="列表LIST"><a href="#列表LIST" class="headerlink" title="列表LIST"></a>列表LIST</h3><ul>
<li>List是由一系列特定顺序排列的元素组成—–有序的（与set相对）</li>
<li>用[]表示列表，并用逗号分隔其中的元素，列表的名称常定义为复数，</li>
<li>适用于存储在程序运行期间可能变化的数据集，是可以修改的—-元素可变（与tuple相对）</li>
<li>容纳python的任何对象（与字典相对）</li>
</ul>
<h4 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h4><p>索引访问，下标从0开始。（==C++数组和vector也是索引访问，还记得数组和链表及vector的区别吗==）</p>
<p>注意：python访问最后一个列表元素，使用索引-1，返回列表的最后一个元素，常用于不知道列表长度的情况下，当然倒数第二个元素类推-2，-3，-4(不过列表为空时不能这样使用，会出错)</p>
<h4 id="修改、增加和删除元素"><a href="#修改、增加和删除元素" class="headerlink" title="修改、增加和删除元素"></a>修改、增加和删除元素</h4><p><strong>修改元素</strong>：给列表中的某元素赋新值，重新print即修改</p>
<p><strong>增加元素</strong>：</p>
<ol>
<li><p>列表末尾添加元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'Mary'</span>, <span class="string">'Tom'</span>] </span><br><span class="line">names.append(<span class="string">'Jack'</span>)</span><br><span class="line">print(names)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>python中可以使用append动态的创建列表，如先创建一个空列表，再使用一系列的append()语句添加元素，类似建立一个空的vector，然后不断的push_back()元素</p>
<p>​            2.列表中插入，insert(索引值，新元素值)可以在任何位置添加新元素</p>
<p><strong>删除元素</strong>：</p>
<ol>
<li>根据索引删除元素，元素后期不再使用</li>
</ol>
<p><code>del names[0]</code> </p>
<p>​          2.删除列表末尾的元素，并继续使用存入变量，names.pop(),类似栈的弹出</p>
<p>​          3.删除任何位置的元素，并存入变量，names.pop(索引)</p>
<p>​          4.根据值删除元素，names.remove(‘Mary’),remove只是删除第一个出现的值，如果某元素重复出现多次，应该循环判断是否删除完毕</p>
<h4 id="组织列表"><a href="#组织列表" class="headerlink" title="组织列表"></a>组织列表</h4><ol>
<li>永久性排序，不可恢复，names.sort(),/names.sort(reverse=True)逆序</li>
<li>临时显示特定排序，不影响列表的原始顺序，print(sorted(names))</li>
<li>反转列表的排列顺序，names.reverse(),逆序，如果需要恢复，再次reverse</li>
<li>求列表长度len(names)</li>
</ol>
<h4 id="数值列表"><a href="#数值列表" class="headerlink" title="数值列表"></a>数值列表</h4><ol>
<li>range(start，end)函数，输出从start开始的数字，到end结束（不包括end）</li>
<li>list(range(start, end))函数，把range的结束直接转换为列表</li>
<li>range(start, end, step)可以指定步长增加直到end</li>
</ol>
<h4 id="切片-部分元素"><a href="#切片-部分元素" class="headerlink" title="切片(部分元素)"></a>切片(部分元素)</h4><ol>
<li>指定开始和结尾索引，在结尾索引前停止(不包括结尾处)</li>
<li>没有指定开始索引代表从列表头开始，没有制定结束索引，代表从列表尾结束</li>
<li>复制列表，同时省略起始索引</li>
</ol>
<h3 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h3><p>不可修改的不可变的列表，使用圆括号（）表示，同样使用索引访问元组，即可查询不可修改的列表</p>
<h3 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h3><ul>
<li>花括号表示{key:value},元素是key与value的对应关系组，通过key访问value</li>
<li>key键不能重复，但是值可以重复</li>
<li>字典中的key键是不可变的，无法修改的，但是值value是可变的可修改的，可以是任何对象</li>
<li>无序存储，python对key进行哈希数字运算，根据计算结果决定value的地址，所以是无序，所以key需要是能被哈希的，即必须是不可变类型，数字字符串元组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 还记得C++的map吗</span></span><br><span class="line"><span class="comment"># 添加单个键值对</span></span><br><span class="line">students = &#123;&#125;</span><br><span class="line">students[<span class="string">'Mary'</span>] = <span class="number">5</span> <span class="comment">#增加一个键值对Mary-5</span></span><br><span class="line"><span class="comment"># 添加多个键值对</span></span><br><span class="line"><span class="comment"># 删除元素</span></span><br><span class="line"><span class="keyword">del</span> students[<span class="string">'Mary'</span>]<span class="comment">#删除时要指定字典名和要删除的键</span></span><br><span class="line"><span class="comment"># 遍历字典</span></span><br><span class="line"><span class="keyword">for</span> key，value <span class="keyword">in</span> students.items()</span><br><span class="line"><span class="comment"># 遍历所有的键</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> students.keys():<span class="comment">#方法key（）可以省略，但是加上更好，key返回一个包含字典中所有键的列表</span></span><br><span class="line"><span class="comment"># 遍历所有的值</span></span><br><span class="line"><span class="keyword">for</span> age <span class="keyword">in</span> students.values():<span class="comment">#方法values（）返回一个包含字典中所有值的列表</span></span><br></pre></td></tr></table></figure>

<h3 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h3><ul>
<li>花括号表示{}，无序的，不重复的，任意的元素，是不是跟C++的set很像</li>
<li>一般用set去掉重复元素</li>
<li>集合不能切片也不能使用索引，毕竟是无序的</li>
</ul>
<p>总结：每个数据结构应该处理哪些数据，应用在哪些场景中</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>W老师语录</title>
    <url>/posts/4c3f0d3b.html</url>
    <content><![CDATA[<p>研究生进入我们实验室，并受到了W老师学习上和思想上的多次教导，受益匪浅。<br>特此记录，以勉励自己未来继续努力。<br>W老师是我见过最好的老师，最棒的老师，真正的科研思维。</p>
<a id="more"></a>

<ol>
<li>爱因斯坦：“大学教育的价值不在于记住很多事实，而是训练大脑会思考”</li>
<li>冯·卡门：“科学家研究已有的世界，工程师创造未来的世界”。<br>科学家与工程师的区别最先在于科学与工程两个概念的区别：科学在于探索客观世界中存在的客观规律，所以科学强调分析，强调结论的唯一性；工程是人们综合应用科学理论和技术手段去改造客观世界的实践活动，所以工程强调综合，强调方案比较论证。这也是科学与工程的主要不同之处。</li>
<li>“指南”通常也意味着需求。</li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>“随笔”</tag>
      </tags>
  </entry>
  <entry>
    <title>写在嘉陵江畔</title>
    <url>/posts/2bc0ac71.html</url>
    <content><![CDATA[<p>本该秋雨绵绵的时节，不过重庆向来与秋无缘，昨天嘉陵江畔烧烤我们还大汗淋漓，今早起床感觉一秒入冬。这种天气本该不喜，不过想想这该是我最后享受重庆的湿冷，享受重庆的风土人情，果断出门，冬风细雨也难以阻挡这最后的步伐</p>
<a id="more"></a>

<!-- ![IMG_4676](/images/IMG_4676.jpg)-->
<img src="/posts/2bc0ac71/IMG_4676.jpg" class title="IMG_4676">
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>两小时一起快速搭建个人博客</title>
    <url>/posts/8f145c5e.html</url>
    <content><![CDATA[<p>两个小时的时间我一般用来鉴赏影片，不过搭一个博客刚好也OK。<br>搭建一个自己的博客需三部曲：<strong><em>下载安装包，部署环境，美化博客页面</em></strong></p>
<a id="more"></a>

<h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><p>本文用的博客是使用Hexo + Github，需要安装以下内容：</p>
<ol>
<li><p>安装Node.js，安装地址：<a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">Node.js下载链接</a></p>
</li>
<li><p>安装Git，安装地址：<a href="http://git-scm.com/download/" target="_blank" rel="noopener">Git下载地址</a><br>对于以上两个安装Mac建议从Homebrew安装node和git，那需要先安装Homebrew。<br>a. 首先打开官网 <a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a> ，你会在官网主页看到如下所示的内容:<br><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</code><br>b. 打开终端，输入上述命令,  即：<br><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</code><br>c. 点击回车<br>d. 输入电脑密码，等待安装<br>e. 显示Installation successful!表示安装成功<br>f. 开始使用命令行安装node和git，<code>brew install node</code> 和<code>brew install git</code></p>
</li>
<li><p>安装Hexo，使用npm安装，建议用root权限，不然会有权限问题。<br>a. 输入命令<code>sudo npm install -g hexo-cli</code>开始安装<br>b. 初始化blog文件夹<code>hexo init blog</code>,这里会从npm源安装，很容易卡住，建议使用淘宝的npm镜像，安装速度很快，依次输入以下命令<code>npm config set registry https://registry.npm.taobao.org</code>和<code>npm info express</code>,第二个命令是看看npm是否装好，此时再初始化blog文件夹（ATTENTION:如果你刚刚init过程失败，你要把生成的blog删除，再执行<code>hexo init blog</code>）<br>c. <code>cd blog</code><br>d. <code>npm install</code><br>e. <code>hexo g</code>这个命令是生成网页的静态文件，会生成一个public的文件<br>f. <code>hexo s</code>这个是启动本地服务，这样你就可以在 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 中预览你的博客</p>
<p>至此已经完成了搭建博客的三分之一了。</p>
</li>
</ol>
<h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><ol>
<li>git的创建，首先你需要一个github的账号，默认已有，然后在你的git主页创建一个新的仓库，点击New repository。填入创建仓库的名称，必须是Yournsername.github.io这很关键，也就是你后面博客的网址。最后直接点击最下面的创建按钮，其他什么都不要动。</li>
<li>hexo关联到Github，打开blog文件夹，里面有一个名为_config.yml的文件，用文本编辑器打开并编辑他，在文档最后deploy，输入以下信息<br><code>deploy</code>:<br><code>type: git</code><br><code>repo: https://github.com/TristaWWP/TristaWWP.github.io.git</code><br><code>branch: master</code></li>
<li>安装扩展<code>npm install hexo-deployer-git --save</code></li>
<li>完成部署<code>hexo d</code>，期间会输入你的用户名和密码。</li>
</ol>
<h2 id="美化博客页面"><a href="#美化博客页面" class="headerlink" title="美化博客页面"></a>美化博客页面</h2><p>俗语说：人靠衣装，确实，我就很喜欢好看的衣服，同样博客也要靠主题的装扮，虽然博客中自带了主题，但是越好看的主题越能展现一个人的个性。你可以进入<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网</a>选择自己喜欢的主题，我一开始选的next主题，后来感觉这个貌似超多人用，于是在官网选购一番，耗时半小时之久都没选到喜欢的，还是用回了next，在这里我太佩服前端和UI的小伙伴了。</p>
<ol>
<li>进入主题文件夹 <code>cd blog</code></li>
<li>下载主题 <code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code></li>
<li>修改主题的配置文件_config.yml中的theme属性，设置为next</li>
<li>然后进行一系列的美化页面效果，请参看这位老哥的文章，十分全面，<a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">Next主题的个性化教程</a></li>
<li>然后就可以创建一篇新的博客<code>hexo new &quot;博客标题&quot;</code>，会产生一个md文件，用文本编辑器打开，并且在里面任意发挥开始你的第一篇博客吧。</li>
<li>简单两行完成发布文章，以后每次这样进行就可以更新博客了<code>hexo g</code>  <code>hexo d</code></li>
</ol>
<p>对于网速实在很差的实验室来说，应该刚好两个小时搞定，不过写这篇博文又用了两个小时。。。</p>
]]></content>
      <categories>
        <category>软件类使用</category>
      </categories>
      <tags>
        <tag>软件类使用</tag>
      </tags>
  </entry>
</search>
